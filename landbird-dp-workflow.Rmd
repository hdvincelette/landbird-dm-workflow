---
title: "Landbird Data Processing Workflow"
name: Hannah
date: "`r format(Sys.time(), '%B %Y')`"
output:
  html_notebook:
    toc: yes
    number_sections: yes
  html_document:
    toc: yes
    df_print: paged
address: Alaska Regional Office 1011 E Tudor Rd, Anchorage, AK
email: hannah_vincelette@fws.gov
github: "https://github.com/hdvincelette/landbird-dp-workflow"
surname: Vincelette
position: Wildlife Biologist
editor_options:
  chunk_output_type: console
---

# Overview

The purpose of this document is to provide a reproducible workflow for processing data collected annually by the Landbird section of USFWS Alaska Migratory Bird Management. Data processing is just one component of data management. For complete guidance, view the [Alaska Region Interim Data Management User Guide.](https://ak-region-dst.gitbook.io/alaska-region-interim-data-management-user-guide/)

#### What is an R Notebook?

["An R Notebook is an R Markdown document with chunks that can be executed independently and interactively, with output visible immediately beneath the input." - R Markdown: The Definitive Guide](https://bookdown.org/yihui/rmarkdown/notebook.html)

#### How to use this guide

This document is meant to be interactive, with text prompts and "code chunks" which may require input before being executed. The following workflow was created for tabular data collected annually for projects archived on the Regional Data Repository. While effort is made to generalize code to all actively collected data, further edits may be required to process data in an standardized format. In this case, it is recommended users duplicate and rename the "landbird-dp-workflow.Rmd" before making changes.

# Workspace setup

### Load packages

Run the following installation code.

```{r include=FALSE, results=TRUE}

# Clear environment
rm(list=ls())

# Install CRAN packages
if (!require("pacman"))
  install.packages("pacman")
pacman::p_load("devtools", "move", "auk", "magrittr", "shiny","bslib")

# Load project
setwd(dirname(rstudioapi::documentPath()))
rstudioapi::filesPaneNavigate(getwd())
devtools::load_all()

theme.selection<- shinythemes::shinytheme("superhero")

# Install GitHub packages
## Uninstall packages (if re-installing)
# remove.packages("FWSAkRDRtools")
# remove.packages("mdJSONdictio")
# .rs.restartR()

## Set GitHub download file method (optional)
# options(download.file.method = "wininet")

## Install FWSAkRDRtools from GitHub
devtools::install_github("hdvincelette/FWSAkRDRtools")

## Install mdJSONdictio from GitHub
devtools::install_github("hdvincelette/mdJSONdictio")


```

If the installations fail, refer to [Install mdJSONdictio R package](https://hdvincelette.github.io/mdJSONdictio/articles/03_Setup_mdJSONdictio.html#install-mdjsondictio-r-package) for troubleshooting tips.

### Create subfolders

Run the following installation code to install necessary subfolders

```{r}

fs::dir_create(names(which(!fs::dir_exists(
  c(
    "downloads/dictionaries",
    "downloads/data",
    "downloads/templates",
    "data-raw",
    "data-processed/bander_portal",
    "data-processed/movebank",
    "data-processed/to_archive",
    "data-processed/data_packages/"
  )
))))

```

# Data preprocessing

### Download authoritative files

Open the [Migratory Bird Management Regional Data Repository](file://ifw7ro-file.fws.doi.net/datamgt/mbm/) and navigate to the project folder. If you are working from a remote location, you must be connected to the VPN (Virtual Private Network) to access this folder.

Paste the names of the project folder, data dictionary(ies), and data entry template(s).

```{r include=FALSE}

# Provide the relevent information
RDR.keyword <- "Eareckson"

```

Now run the following code chunk.

```{r include=FALSE, results=FALSE}


if(dir.exists(paste0("//ifw7ro-file.fws.doi.net/datamgt/mbm/"))==FALSE) {
  stop("Check the VPN connection and try again.")
}

project.folder <- dir(
  path = paste0("//ifw7ro-file.fws.doi.net/datamgt/mbm/"),
  pattern = paste0("^mbmlb.*", RDR.keyword),
  full.names = FALSE,
  recursive = FALSE,
  ignore.case = TRUE
)

if(length(project.folder)>1) {
  folder.choice <- utils::menu(
    c(project.folder),
    graphics = TRUE,
    title = cat(
      paste0(
        "\nMore than one project folder was found.\nSelect one to access.\n"
      )
    )
  )
}

select.download.app(
  dir = paste0("//ifw7ro-file.fws.doi.net/datamgt/mbm/", project.folder),
  ext = ".*",
  multiple = TRUE
)

for (y in 1:nrow(selected.files)) {
  downloader::download(
    url =
      paste0(
        "File://",
        gsub("^[[:punct:][:space:]]+", "", selected.files$path[y]),
        "/",
        selected.files$filename[1]
      ),
    destfile = file.path(selected.dir, selected.files$filename[y]),
    method = "auto",
    mode = "wb",
    quiet = FALSE
  )
}



```

View and verify the downloaded data dictionary(ies) and data entry template(s) (the default location is the "downloads" sub-folder of this R project).

*Optional: You can skip the above steps and download everything manually from the [Migratory Bird Management Regional Data Repository](file://ifw7ro-file.fws.doi.net/datamgt/mbm/) project folder. Data dictionaries and data entry templates should be available in the "metadata" sub-folder. Save a copy of data dictionary(ies) and data entry template(s) in an accessible location (i.e. the "downloads" sub-folder of this R project)*

### Enter data

Copy and save each data entry template in a preferred location for data entry (this can be in the "data-raw" sub-folder of this R project). Use a unique and descriptive name - refer to [Best Practices in Naming Conventions](https://ak-region-dst.gitbook.io/alaska-region-interim-data-management-user-guide/alaska-data-management-101/file-organization-and-best-practices/best-practices-in-naming-conventions). It's okay to save this file in an Excel file format to preserve validation rules.

Enter scanned or hard copy data according to the respective data dictionary(ies). Review entered data to check for errors. The Excel Filter function (Home\>Editing\>Filter) is especially useful for viewing unique values and value ranges.

Save the entered data file(s) in the "data-raw" sub-folder of this R project. Convert the file(s) to comma-separated values (CSV) format, if necessary. Make sure the correct sheet is selected when converting if more than one sheet is used (i.e., validation rules).

# Data quality checks

Before beginning, make sure all entered data and data dictionary(ies) are saved in the sub-folders of this R project ("data-raw" and "downloads", respectively).

### Provide inputs

```{r}

# Provide the relevant information (if applicable)
missing_values<- c(NA)
species.col <- "SpeciesCode"
date.col <- "Date"
date.format <-  "%m/%d/%Y"
time.col <- "CaptureTime_2400"
time.format <- "%H:%M"

```

### Import

```{r}


select.import.app(dir = paste0(dirname(rstudioapi::documentPath()),"/data-raw"), 
                  ext = c("txt", "csv", "xls*"),
                  multiple = TRUE)

raw.data.list <- importer(
  path = selected.files$path[1],
  files = selected.files$filename,
  column.format = list(
    c(column = date.col, format = date.format),
    c(column = time.col, format = time.format)
  )
)

data.filenames<- tools::file_path_sans_ext(selected.files$filename)

select.import.app(dir = paste0(dirname(rstudioapi::documentPath()),
                               "/downloads/dictionaries"),
                  ext = c("json","csv", "xls*"), 
                  multiple = FALSE)

ref.dictionary <- importer(path = selected.files$path[1],
                            files = selected.files$filename)[[1]]

dxnry.filename<- tools::file_path_sans_ext(selected.files$filename)

```

### Filter data

```{r}

aou_code <- read.csv("reference/IBP-AOS-LIST23.csv", na = "")

## Translate species names/codes (if neccessary)
# 
# raw.data.list <- raw.data.list %>%
#   purrr::map(
#     .f = ~ .x %>%
#       dplyr::rename_with(., ~gsub('\\.', '', .x)) %>%
#       dplyr::inner_join(
#         .,
#         aou_code[, c("COMMONNAME", "SPEC")],
#         by = c("CommonName" = "COMMONNAME"),
#         keep = FALSE,
#         relationship = "many-to-many"
#       ) %>%
#       dplyr::mutate("SpeciesCode" = `SPEC`) %>%
#       dplyr::select(-"SPEC")
#   )
# 
# # Check species names/codes
# raw.data.list %>%
#   purrr::map(.f = ~ .x %>%
#                dplyr::filter(!.data[[species.col]] %in% aou_code$SPEC))


if(any(c(species.col, date.col) %in% unlist(purrr::map(raw.data.list, colnames)))) {
  # Make filter selections
  if (species.col %in% unlist(purrr::map(raw.data.list, colnames))) {
    species <- unique(purrr::map(raw.data.list, ~ .x %>%
                                   purrr::pluck(species.col)) %>%
                        unlist(.))
  } else {
    species<- character(0)
  }
  
  
  if (date.col %in% unlist(purrr::map(raw.data.list, colnames))) {
    date.ranges <- raw.data.list %>% purrr::map(
      .f = ~ .x %>%
        dplyr::mutate("{{date.col}}" := ifelse(!date.col %in% names(.), "", {{date.col}})) %>%
        dplyr::select(any_of(date.col)) %>%
        dplyr::filter(.data[[date.col]] != "") %>%
        dplyr::mutate_at(dplyr::vars(tidyselect::any_of(date.col)), as.Date, format = date.format) %>%
        # dplyr::mutate({{date.col}} := as.Date(.data[[date.col]], format = date.format)) %>%
        append(list(
          "Min" = min(.[[date.col]]), "Max" = max(.[[date.col]])
        ))
    )
    
  
    dates.df <- raw.data.list %>% purrr::map(
      .f = ~ .x %>%
        dplyr::mutate({{date.col}} := ifelse(!date.col %in% names(.), "", .data[[date.col]])) %>%
        dplyr::select(all_of(date.col)) %>%
        dplyr::filter(.data[[date.col]] != "") %>%
        dplyr::mutate({{date.col}} := as.Date(.data[[date.col]], format = date.format))
    ) %>%
      dplyr::bind_rows(., .id = "id")
    
    min.date <- min(do.call("c", lapply(date.ranges, "[[", "Min")))
    max.date <- max(do.call("c", lapply(date.ranges, "[[", "Max")))
    
  } else {
    min.date <- as.Date("0001-01-01")
    max.date <- as.Date("0001-01-01")
  }
  
  


  filter.df.app(raw.data.list, species.col, date.col, species, min.date, max.date)


# Apply filters
  id.var <- dplyr::last(make.names(c(unique(
    unlist(purrr::map(raw.data.list, colnames))
  ), ".id"), unique = TRUE))
  
  
  raw.data.list <- raw.data.list %>%
    purrr::map(.f = ~ .x %>%
                 tibble::rowid_to_column(var = id.var))
  
  other.data.list <- raw.data.list
  
  if (length(species) != 0) {
    raw.data.list <- raw.data.list %>%
      purrr::map(.f = ~ .x %>%
                   dplyr::filter(if_any(
                     matches(species.col), ~ .data[[species.col]] %in% selected.species
                   )))
  }
  
  
  if (min.date != "0001-01-01" |
      max.date != "0001-01-01") {
    raw.data.list <- raw.data.list %>%
      purrr::map(
        .f = ~ .x %>%
          dplyr::mutate_at(dplyr::vars(tidyselect::any_of(date.col)), as.Date, format = date.format) %>%
          dplyr::filter(if_any(
            matches(date.col),
            ~ data.table::between(.data[[date.col]], min(selected.dates), max(selected.dates), NAbounds =
                                    FALSE)
          ))
      )
  }
  
  rm.row <-  purrr::map(raw.data.list, id.var)
  
  other.data.list <- lapply(seq_along(rm.row), function(i) {
    if (rlang::is_empty(rm.row[[i]]) == FALSE) {
      other.data.list[[i]] %>%
        dplyr::slice(-rm.row[[i]])
    } else {
      other.data.list[[i]]
    }
  }) %>%
    purrr::set_names(names(raw.data.list))
  
  raw.data.list <-
    purrr::map(raw.data.list, ~ (.x %>%
                                   dplyr::select(-tidyselect::any_of(id.var))))
  
  other.data.list <- 
    purrr::map(other.data.list, ~ (.x %>% 
                                     dplyr::select(-tidyselect::any_of(id.var))))
   

# Remove empty dataframes
      raw.data.list <- raw.data.list %>%
        purrr::discard(., ~ nrow(.) == 0) %>%
        purrr::map(.f = ~ .x %>%
                           dplyr::mutate_at(dplyr::vars(tidyselect::any_of(date.col)), format, format = date.format))
                     
      
      other.data.list <- other.data.list %>%
        purrr::discard(., ~ nrow(.) == 0) %>%
         purrr::map(.f = ~ .x %>%
                           dplyr::mutate_at(dplyr::vars(tidyselect::any_of(date.col)), format, format = date.format))
  
}
```

### Merge data

```{r}

if(length(raw.data.list)>1) {
  # Make data frame selections
  merge.df.app(raw.data.list)
  
  # Execute forced rbind
  if (is.null(selected.df) == FALSE) {
    raw.data.list <-  c(list(merged_data = data.table::rbindlist(raw.data.list[names(raw.data.list) %in% selected.df], fill = TRUE)),
                        raw.data.list[!names(raw.data.list) %in% selected.df])
  }
  
  raw.data.list <- raw.data.list %>%
    purrr::map(
      .f = ~ .x %>%
        dplyr::mutate_if(is.character, ~ dplyr::na_if(., "")) %>%
        dplyr::mutate_if(is.character, ~ dplyr::na_if(., "NULL")) %>%
        dplyr::mutate_if(is.character, ~ dplyr::na_if(., missing_values))
    )
}

```

### Validate data

```{r}

# Validate data file(s) against the dictionary
warning.list <- list()
assign("input.dxnry", ref.dictionary)
if (class(ref.dictionary) == "list") {
  input.dxnry <- mdJSONdictio::extract.mdJSON(x = input.dxnry,
                                              record.type = "dictionaries",
                                              multiple = FALSE)
  
  record.num <-  which(sapply(ref.dictionary[["data"]], "[", "id") == input.dxnry[["data"]][[1]][["id"]])
  
  
  dxnry.colnames <- unlist(sapply(rjson::fromJSON(input.dxnry[["data"]][[1]][["attributes"]][["json"]])[["dataDictionary"]][["entity"]][[1]][["attribute"]], "[", "codeName"))
} else {
  dxnry.colnames <- unique(input.dxnry$codeName)
}
   
for (a in 1:length(raw.data.list)) {
  assign("input.data", raw.data.list[[a]])
  
  # Check colnames
  invalid.cols <- colnames(input.data)[!colnames(input.data) %in% dxnry.colnames]
  
  
  if (length(invalid.cols) != 0) {
    for (invalid.col in invalid.cols) {
      unused.cols <- as.vector(dxnry.colnames[!dxnry.colnames %in% colnames(input.data)])
      
      correct.colname.app(input.data, invalid.col, unused.cols)
      
      
      if (decision == "remove") {
        input.data <- input.data %>% dplyr::select(., -invalid.col)
        
      } else if (decision == "replace") {
        input.data <- input.data %>% dplyr::rename(., !!col.choice := !!invalid.col)
        unused.cols <- unused.cols[!unused.cols %in% col.choice]
        
      } else if (decision == "rename") {
        input.data <- input.data %>% dplyr::rename(., !!col.choice := !!invalid.col)
      }
    }
  }
  
  # Create warning table
  if (class(ref.dictionary) == "list") {
    warning.list[[a]] <-
      mdJSONdictio::validate.mdJSON(x = input.dxnry, y = input.data)
  } else {
    warning.list[[a]] <-
      mdJSONdictio::validate.table(x = input.dxnry, y = input.data)
  }
  
  raw.data.list[[a]] <- input.data
  
}

names(warning.list) <- names(raw.data.list)


```

### Correct data

```{r}

for (a in 1:length(raw.data.list)) {
  assign("input.data", raw.data.list[[a]])
  
  if (class(ref.dictionary) == "list") {
    ref.dxnry <- mdJSONdictio::build.table(input.dxnry)
  } else {
    assign("ref.dxnry", input.dxnry)
  }
  
  warn.table <- warning.list[[a]]
  
  # Correct entry errors
  domainItem_value.table <-
    warn.table %>% dplyr::filter(Category == "domainItem_value")
  
  if (nrow(domainItem_value.table) != 0) {
    for (b in 1:nrow(domainItem_value.table)) {
      invalid.values <-
        scan(
          text = noquote(gsub(
            ".*: ", "", domainItem_value.table$Message[b]
          )),
          what = "",
          quiet = TRUE,
          sep = ",",
          strip.white = TRUE
        )
      
      
      variable <- domainItem_value.table$Variable[b]
      
      choose.value.app(variable, invalid.values, ref.dxnry)
      
      #!!# temporary patch
      if ("" %in% selected.values) {
        selected.values <- ifelse(selected.values == "", "NA", selected.values)
      }
      
      for (invalid.value in selected.values) {
        correct.value.app(variable, invalid.value, input.data, ref.dxnry)
        
        if (decision %in% c("correct", "replace")) {
          class <- class(input.data[[variable]])
          
          input.data <- input.data %>%
            dplyr::mutate_at(
              variable,
              ~ as.character(.) %>% dplyr::recode(., !!invalid.value := value.choice)
            )
          
          # if (numeric == TRUE &
          #     is.numeric(input.data[[variable]]) == TRUE) {
          #   input.data <- input.data %>%
          #     dplyr::mutate_at(variable, ~ as.numeric(.))
          #   
          # }
          # 
          # if (is.na(match.fun(paste0("as.", class))(value.choice))
          #   == TRUE) {
          #     
          #   }
          
        }
        
        
      }
    }
  }
  
      
  #     test<- summary(arsenal::comparedf(
  #   dplyr::mutate(df, across(
  #     where(is.character), ~ dplyr::na_if(.x, "")
  #   )),
  #   dplyr::mutate(input.data, across(
  #     where(is.character), ~ dplyr::na_if(.x, "")
  #   ))
  # ))
      
  
  raw.data.list[[a]] <- input.data
}

raw.data.list <- purrr::map(raw.data.list, ~ (.x %>% dplyr::select(-tidyselect::any_of(id.var))))


```

### Correct dictionary

```{r}

req.attribute.fields <-
      c("codeName", "allowNull", "dataType", "definition", "domainId")

for (a in 1:length(warning.list)) {
  warn.table <- warning.list[[a]]
  
  
  # codeName
  codeName.warn <-
    warn.table %>% dplyr::filter(Category == "codeName")
  
  if (nrow(codeName.warn) != 0) {
 
    add.codeName.app(
      data = as.data.frame(raw.data.list[[a]]),
      filename = names(raw.data.list[a]),
      missing.variables = codeName.warn$Variable
    )
    
    if (length(codeName.choice)!=0) {
      for (b in 1:length(codeName.choice)) {
        if (class(ref.dictionary) == "list") {
          input.dxnry <-
            mdJSONdictio::modify.mdJSON(
              x = input.dxnry,
              how = "add_attribute",
              attribute_codeName = codeName.choice[b],
              attribute_units = NULL,
              attribute_unitsResolution = NULL,
              attribute_isCaseSensitive = NULL,
              attribute_missingValue = NULL,
              attribute_minValue = NULL,
              attribute_maxValue = NULL,
              attribute_fieldWidth = NULL,
              quiet = FALSE
            )
        } else {
          input.dxnry <-
            mdJSONdictio::modify.table(
              x = input.dxnry,
              how = "add_attribute",
              attribute_codeName = codeName.choice[b],
              attribute_units = NULL,
              attribute_unitsResolution = NULL,
              attribute_isCaseSensitive = NULL,
              attribute_missingValue = NULL,
              attribute_minValue = NULL,
              attribute_maxValue = NULL,
              attribute_fieldWidth = NULL,
              quiet = FALSE
            )
        }
      }
    }
  }
  

  # domainItem_value
  domainItem_value.table <-
    warn.table %>% dplyr::filter(Category == "domainItem_value")
  
  if (class(ref.dictionary) == "list") {
    ref.dxnry <- mdJSONdictio::build.table(input.dxnry)
  } else {
    assign("ref.dxnry", input.dxnry)
  }
  
  if (nrow(domainItem_value.table) != 0) {
    for (b in 1:nrow(domainItem_value.table)) {
      domainItem.vector <-
        scan(
          text = noquote(gsub(
            ".*: ", "", domainItem_value.table$Message[b]
          )),
          what = "",
          quiet = TRUE,
          sep = ",",
          strip.white = TRUE
        )
      
      add.domainItem.app(
        domainItem_value.table$Variable[b],
        domainItem.vector,
        ref.dxnry)
      
      if (length(domainItem.choice)!=0) {
        for (c in 1:length(domainItem.choice)) {
          
          if (class(ref.dictionary) == "list") {
            input.dxnry <-
              mdJSONdictio::modify.mdJSON(
                x = input.dxnry,
                how = "add_domainItem",
                domain_codeName = domainItem_value.table$Variable[b],
                domainItem_name = domainItem.choice[c],
                domainItem_value = domainItem.choice[c],
                quiet = FALSE
              )
          } else {
            input.dxnry <-
              mdJSONdictio::modify.table(
                x = input.dxnry,
                how = "add_domainItem",
                domain_codeName = domainItem_value.table$Variable[b],
                domainItem_name = domainItem.choice[c],
                domainItem_value = domainItem.choice[c],
                quiet = FALSE
              )
          }
        }
        
      }
    }
  }
  
  # dataType
  
  dataType.table <-
    warn.table %>% dplyr::filter(Category == "dataType_RDatatype")
  
   dataType.vector <- get0("dataType.vector", envir = asNamespace("mdJSONdictio"))
   
   datatype.rules <- get0("datatype.rules", envir = asNamespace("mdJSONdictio"))
  
  if (nrow(dataType.table) != 0) {
    for (b in 1:nrow(dataType.table)) {
      detected.dataType <-
        gsub("[\\(\\)]",
             "",
             regmatches(
               dataType.table$Message[b],
               gregexpr("\\(.*?\\)", dataType.table$Message[b])
             )[[1]])[1]
      dxnry.dataType <-
        gsub("[\\(\\)]",
             "",
             regmatches(
               dataType.table$Message[b],
               gregexpr("\\(.*?\\)", dataType.table$Message[b])
             )[[1]])[2]
      
      correct.dataType.app(
        variable = dataType.table$Variable[b],
        dxnry.dataType = dxnry.dataType,
        detected.dataType = detected.dataType,
        data = raw.data.list[[a]],
        filename = names(raw.data.list[a])
      )
      
       if ("update" %in% dataType.choice) {
        input.dxnry <-
          mdJSONdictio::modify.mdJSON(
            x = input.dxnry,
            how = "update_attribute",
            attribute_codeName = dataType.table$Variable[b],
            attribute_allowNull = NULL,
            attribute_dataType = dataType.choice,
            attribute_definition = NULL,
            attribute_units = NULL,
            attribute_unitsResolution = NULL,
            attribute_isCaseSensitive = NULL,
            attribute_missingValue = NULL,
            attribute_minValue = NULL,
            attribute_maxValue = NULL,
            attribute_fieldWidth = NULL,
            domain_codeName = NULL,
            new.attribute_codeName = NULL,
            quiet = FALSE
          )
        
      }
    }
  }

}

ref.dictionary[["data"]][[record.num]] <- input.dxnry[["data"]][[1]]

  
```

### Final checks

```{r}
# continuous: box plots
# discrete: range of values (interactive table)
# plot lat/long
# Check flag code, flag color, and leg attachments for recaps

# Check/correct time cols

# All data
for (x in 1:length(raw.data.list)) {
  assign("input.data", raw.data.list[[x]])
  
  ## Duplicate rows

  
  # All capture data
  
  ## Unique values
  ### BBLDisposition = 1 & BandNumberOut
  ### Flag code & BandNumberOut
  ### Colorband combo & BandNumberOut

  ## Species v AOU codes
  
  ## Status codes
 
  ## "Out" leg_cols contains an X
  leg_cols <-   c("ULIn",
                  "LLIn",
                  "URIn",
                  "LRIn",
                  "ULOut",
                  "LLOut",
                  "UROut",
                  "LROut")
  
  leg_cols <- leg_cols[leg_cols %in% colnames(input.data)]
  
  which(rowSums(is.na(input.data[, leg_cols[grepl("Out", leg_cols)]])) == 4)
  
  # Recapture data
  ## "In" leg_cols contains an X
  which(rowSums(is.na(input.data[, leg_cols[grepl("In", leg_cols)]])) == 4 &
          input.data$BBLDisposition == "R")
  
  ## BandNumberIn == BandNumberOut
  which(is.na(input.data$BandNumberIn) &
          input.data$BBLDisposition == "R")
  
  raw.data.list[[x]] <- input.data
  
}

```

# Data postprocessing

### Add uuids

```{r}
raw.data.list <- raw.data.list %>%   purrr::map(
  .f = ~ .x %>%       dplyr::mutate(!!!setNames(
    rep(NA, length(setdiff(
      "OccurenceID", colnames(.x)
    ))), setdiff("OccurenceID", colnames(.x))
  )) %>% dplyr::relocate("OccurenceID") %>%       dplyr::rowwise() %>%       dplyr::mutate_at(
    "OccurenceID",
    ~ ifelse(is.na(.) == TRUE ||
               . == "", uuid::UUIDgenerate(use.time = FALSE), .)
  )
)    
```

### Join ancillary data

#### Location

```{r}
# Provide directory paths for the location data file(s)
ref.data.path <- "reference/ALMS/"

# Provide the relevent information
ref.point.prefix <- "EIEL_"
data.point.col <- "UnitID"
data.lat.col <- "Latitude_dec"
data.long.col <- "Longitude_dec"

```

```{r}

# Import reference data file(s)
ref.data.files <- importer(
  path = ref.data.path,
  multiple = TRUE,
  graphics = TRUE,
  pattern = c("*.gpx$", "*.kml$")
)

locations<- data.table::rbindlist(ref.data.files, fill = TRUE)

# Join location(s)
raw.data.list <- raw.data.list %>%
  purrr::map(
    .f = ~ .x %>%
      dplyr::left_join(
        .,
        locations,
        by = c(setNames("temp:Name", data.point.col)), 
               # "Year" = "temp:year"),
        keep = FALSE
      ) %>%
      dplyr::mutate_at(
        data.lat.col,
        ~ dplyr::case_when(is.na(.) ~ `temp:Latitude`, TRUE ~ !!as.name(data.lat.col))
      ) %>%
      dplyr::mutate_at(
        data.long.col,
        ~ dplyr::case_when(is.na(.) ~ `temp:Longitude`, TRUE ~ !!as.name(data.long.col))
      ) %>%
      dplyr::select(-tidyselect::starts_with("temp:"))
  )
    
```

#### Sex results

```{r}
file.path = "C:/Users/hvincelette/OneDrive - DOI/Documents/Fieldwork_wrap/2023/Sexing_Analysis/"
```

```{r}

# Import sex results
sex_results <- importer(path = file.path,
                        multiple = FALSE,
                        graphics = TRUE)



# Correct results table
sex_results<- sex_results %>%
  dplyr::mutate_at("BandNumber", as.character) %>%
  tidyr::drop_na("OccurenceID") %>%
  dplyr::filter(Sex %in% c("F","M"))


# Check for duplicate results (creates duplicate rows in left_join)
sex_results[c(
  anyDuplicated(sex_results$BandNumber, fromLast = TRUE),
  anyDuplicated(sex_results$BandNumber, fromLast = FALSE)
), ]


# Join sex results
raw.data.list <- raw.data.list %>%
  purrr::map(
    .f = ~ .x %>%
      dplyr::mutate(!!!setNames(
        rep(NA, length(setdiff(
          "CHDSex", colnames(.x)
        ))), setdiff("CHDSex", colnames(.x))
      )) %>%
      dplyr::relocate("CHDSex", .before = "FieldSex") %>%
      dplyr::left_join(.,dplyr::distinct(sex_results[,c("BandNumber","Sex")]), by = c("BandNumberOut" = "BandNumber"), keep = FALSE, relationship = "many-to-many") %>%
    dplyr::mutate_at("CHDSex", ~dplyr::case_when(is.na(.) ~ Sex,TRUE ~ CHDSex)) %>%
      dplyr::select(-"Sex")
    )


```

### Fill missing info

#### Bird status

```{r}

ref_data <-
  lapply(list.files(path = "reference/bander_portal/", full.names = TRUE),
         readxl::read_excel)

names(ref_data) <-
  gsub(
    list.files(path = "reference/bander_portal/"),
    pattern = ".xlsx$",
    replacement = ""
  )

list2env(ref_data, globalenv())

for (x in 1:length(raw.data.list)) {
  assign("input.data", raw.data.list[[x]])
  
  # Add missing columns
  miss_cols <- setdiff(
    c(
      na.omit(capture_cols$my_col[!grepl("color", capture_cols$my_col)]),
      "TagType1",
      "TagType2",
      "TagStatus1",
      "TagStatus2"
    ),
    colnames(input.data)
  )
  
  input.data[miss_cols] <-
    as.character(NA)
  
  
  my_colors <- c(
    "Bk",
    "Br",
    "Db",
    "Lb",
    "Mb",
    "Dg",
    "Lg",
    "Gy",
    "Hp",
    "Mg",
    "Mv",
    "Or",
    "Pp",
    "Rd",
    "Wh",
    "Yl"
  )
  
  leg_cols <-   c("ULIn",
                  "LLIn",
                  "URIn",
                  "LRIn",
                  "ULOut",
                  "LLOut",
                  "UROut",
                  "LROut")
  
  leg_cols <- leg_cols[leg_cols %in% colnames(input.data)]
  
  status_info <- input.data %>%
    dplyr::rowwise() %>%
    dplyr::mutate_at("TagType1", ~ ifelse(TagStatus1  %in% c("Removed", "Lost"), TagType1 <-
                                            NA
                                          , .)) %>%
    dplyr::mutate_at("TagType2", ~ ifelse(TagStatus2  %in% c("Removed", "Lost"), TagType2 <-
                                            NA
                                          , .)) %>%
    dplyr::select(tidyselect::any_of(
      c(
        "OccurenceID",
        "BandNumberOut",
        "SpeciesCode",
        "BBLStatus",
        leg_cols[grepl("Out", leg_cols)],
        "TagType1",
        "TagType2",
        "Blood",
        "BBLStatus"
      )
    )) %>%
    dplyr::mutate_at(dplyr::vars(c(
      leg_cols[grepl("Out", leg_cols)], "TagType1", "TagType2", "BBLStatus"
    )), ~ as.character(.) %>% dplyr::na_if(., "")) %>%
    dplyr::mutate_at(
      leg_cols[grepl("Out", leg_cols)],
      ~ stringi::stri_replace_all_fixed(., my_colors, "01A", vectorize_all = FALSE)
    ) %>%
    dplyr::mutate(NumMarkers = sum(!unique(dplyr::c_across(
      c(leg_cols[grepl("Out", leg_cols)], "TagType1", "TagType2")
    ))  %in% c("X", NA))) %>%
    dplyr::mutate_at(
      "BBLStatus",
      ~ dplyr::case_when(
        NumMarkers >= 2 &
          Blood != "Y" ~ "325",
        NumMarkers >= 1 &
          Blood == "Y" ~ "319",
        NumMarkers == 0 &
          Blood == "Y" ~ "318",
        NumMarkers == 0 &
          Blood != "Y" ~ "300",
        NumMarkers == 1 &
          dplyr::if_any(c(leg_cols[grepl("Out", leg_cols)], "TagType1", "TagType2"), ~
                          . == "69") &
          Blood != "Y" ~ "369",
        NumMarkers == 1 &
          dplyr::if_any(c(leg_cols[grepl("Out", leg_cols)], "TagType1", "TagType2"), ~
                          grepl("^81", .)) &
          Blood != "Y" ~ "381",
        NumMarkers == 1 &
          dplyr::if_any(c(leg_cols[grepl("Out", leg_cols)], "TagType1", "TagType2"), ~
                          grepl("^80", .)) &
          Blood != "Y" ~ "380",
        NumMarkers == 1 &
          dplyr::if_any(c(leg_cols[grepl("Out", leg_cols)], "TagType1", "TagType2"), ~
                          grepl("^90", .)) &
          Blood != "Y" ~ "390",
        NumMarkers == 1 &
          dplyr::if_any(c(leg_cols[grepl("Out", leg_cols)], "TagType1", "TagType2"), ~
                          grepl("^01", .)) &
          Blood != "Y" ~ "301",
        TRUE ~ BBLStatus
      )
    ) %>%
    dplyr::rename(`temp:BBLStatus` = BBLStatus)
  
  input.data <- input.data %>%
    dplyr::mutate(across(where(is.character), ~ dplyr::na_if(.x, ""))) %>%
    dplyr::left_join(
      .,
      status_info[, c("OccurenceID", "temp:BBLStatus")],
      by = c("OccurenceID" = "OccurenceID"),
      keep = FALSE,
      relationship = "one-to-one"
    ) %>%
    dplyr::mutate_at("BBLStatus", ~ as.character(.)) %>%
    dplyr::mutate_at("BBLStatus",
                     ~ dplyr::case_when(is.na(.) ~ `temp:BBLStatus`, TRUE ~ BBLStatus))
  
  invalid.index <- which(input.data$BBLStatus != input.data$`temp:BBLStatus`)
  
  
  if (length(invalid.index) != 0) {
    for (a in invalid.index) {
      message(cat(
        paste0(
          "The status for the following individual appears invalid.\nSpecies: ",
          input.data$SpeciesCode[a],
          "\nBand number: ",
          input.data$BandNumberOut[a],
          "\nStatus (reported): ",
          input.data$BBLStatus[a],
          " [",
          bander_portal_lookups$description[grepl(stringr::str_sub(input.data$BBLStatus[a], 1, 1),
                                                  bander_portal_lookups$code) == TRUE &
                                              bander_portal_lookups$field == "Bird Status"],
          " ",
          bander_portal_lookups$description[grepl(stringr::str_sub(input.data$BBLStatus[a], 2, 3),
                                                  bander_portal_lookups$code) == TRUE &
                                              bander_portal_lookups$field == "Bird Status Extra Info"],
          "]",
          "\nStatus (detected): ",
          input.data$`temp:BBLStatus`[a],
          " [",
          bander_portal_lookups$description[grepl(
            stringr::str_sub(input.data$`temp:BBLStatus`[a], 1, 1),
            bander_portal_lookups$code
          ) == TRUE &
            bander_portal_lookups$field == "Bird Status"],
          " ",
          bander_portal_lookups$description[grepl(
            stringr::str_sub(input.data$`temp:BBLStatus`[a], 2, 3),
            bander_portal_lookups$code
          ) == TRUE &
            bander_portal_lookups$field == "Bird Status Extra Info"],
          "]",
          "\nBlood: ",
          input.data$Blood[a],
          "\nULOut: ",
          input.data$ULOut[a],
          "\nLLOut: ",
          input.data$LLOut[a],
          "\nUROut: ",
          input.data$UROut[a],
          "\nLROut: ",
          input.data$LROut[a],
          "\nTagStatus1: ",
          input.data$TagStatus1[a],
          "\nTagStatus2: ",
          input.data$TagStatus2[a]
        )
      ))
      
      status.choice <- utils::menu(
        choice = c("update as detected", "manually edit", "leave as is"),
        graphics = TRUE,
        title = cat("\nHow would you like to proceed?")
      )
      
      if (status.choice == 1) {
        input.data$BBLStatus[a] <- input.data$`temp:BBLStatus`[a]
        
        
      }
      if (status.choice == 2) {
        message(
          "\nIMPROTANT: you must click 'syncronise' (arrow loop icon) and then 'Done' to enact changes."
        )
        
        invalid.entries <- input.data %>%
          dplyr::ungroup() %>%
          dplyr::filter(dplyr::row_number() == a)
        
        invalid.entries.edit <-
          DataEditR::data_edit(
            invalid.entries,
            col_readonly = colnames(invalid.entries)[!colnames(invalid.entries) %in% "BBLStatus"],
            viewer = "pane"
          ) %>%
          dplyr::mutate_at("BBLStatus", as.character)
        
        input.data[match(invalid.entries.edit$OccurenceID,
                         input.data$OccurenceID), "BBLStatus"] <-
          invalid.entries.edit$BBLStatus
      }
      
    }
  }
  
  
  input.data <-
    input.data %>%
    dplyr::select(-tidyselect::starts_with("temp:"))
  
  raw.data.list[[x]] <- input.data
  
}
  
```

#### Other variables

```{r}

raw.data.list %>% purrr::map(
  .f = ~ .x %>%
    dplyr::mutate_if(is.character, list(~ dplyr::na_if(., "")))  %>%
    dplyr::select(tidyselect::where(~ any(is.na(
      .
    ))))
)

```

### Export files

#### Provide inputs

```{r}
# Provide directory path for the authoritative data file
download.path <- "downloads/data"

# Provide a directory path to write processed files
# processed.data.path <- "data-processed/to_archive/"

# Do you want to merge the data with an authoritative file?
auth.merge <- FALSE

# Provide versioning format (when merging with an authoritative file)
vers.suffix <- "_v"

```

#### Data

```{r}

# Rejoin filtered data
raw.data.list <-
  split(c(raw.data.list, other.data.list), c(names(raw.data.list), names(other.data.list))) %>%
  purrr::map(dplyr::bind_rows)


if (auth.merge == TRUE) {
  # Select files to merge
  if (length(raw.data.list) > 1) {
    # Make data frame selections
    merge.df.app(raw.data.list)
    
    # Execute forced rbind
    if (is.null(selected.df) == FALSE) {
      add.data <-  data.table::rbindlist(raw.data.list[names(raw.data.list) %in% selected.df], fill = TRUE) %>%
        as.data.frame(.) %>%
        dplyr::mutate_if(is.character, ~ dplyr::na_if(., "")) %>%
        dplyr::mutate_if(is.character, ~ dplyr::na_if(., "NULL")) %>%
        dplyr::mutate_if(is.character, ~ dplyr::na_if(., missing_values))
      
    }
  } else {
     add.data <-  data.table::rbindlist(raw.data.list, fill = TRUE)
  }
  
    
    # Import authoritative data file
    select.import.app(path = download.path, multiple = FALSE)
    
    auth.data <- importer(path = download.path,
                          files = selected.files,
                          column.format = list(
                            c(column = date.col, format = date.format),
                            c(column = time.col, format = time.format)
                          )) %>%
      .[[1]] %>% as.data.frame(.)
    
    auth.filename <- tools::file_path_sans_ext(selected.files)
    
    
    # Add missing columns
    missing.cols <- add.data %>%
      dplyr::mutate_if(is.character, ~ dplyr::na_if(., c(""))) %>%
      purrr::discard(., ~ all(is.na(.))) %>%
      dplyr::select(colnames(.)[!colnames(.) %in% colnames(auth.data)]) %>%
      colnames()
    
    if(length(missing.cols)!=0) {
      add.column.app(missing.cols, add.data)
    }
    

    if (length(col.choice) != 0) {
      for (a in col.choice) {
        existing.cols <- colnames(auth.data)
        place.column.app(a, existing.cols)
        
        if (last == TRUE) {
          auth.data <- auth.data %>% tibble::add_column(!!a := NA, .before = NULL)
        } else if (loc.choice != "") {
          auth.data <- auth.data %>% tibble::add_column(!!a := NA, .before = loc.choice)
        }
        
      }
    }
    
    # Merge data
    new.data <- auth.data %>%
      merge(add.data, all = TRUE, sort = FALSE) %>%
      dplyr::select(colnames(auth.data))
    
    
    #!!!# Evaluate changes
    old <- auth.data %>% 
      dplyr::mutate(across(where(is.character), ~ dplyr::na_if(.x, "")))
    
    new <- new.data %>% 
      dplyr::mutate(across(where(is.character), ~ dplyr::na_if(.x, "")))
    

#     compare.stats<- dataCompareR::locateMismatches(old, new)
#     
#     compare.stats<- dataCompareR::rCompare(old, new)
#     compare.stats<- summary(compare.stats)

        
    compare.stats<- arsenal::comparedf(new, old)
    compare.stats<- summary(compare.stats)
    
    comparison<- compareDF::compare_df(new, old, c("OccurenceID"))
    
    compareDF::create_output_table(
      comparison,
      file_name = "data-processed/comparison/temp.xlsx",
      output_type = "xlsx",
      limit = max(nrow(new), nrow(old))
    ) 
    
    compare.df<- openxlsx::read.xlsx("data-processed/comparison/temp.xlsx")

    compare.dfs.app(new, old, compare.df, compare.stats)

    
    # Versioning
    download.file.app(auth.filename, new.data)
    
    
    
    
    write.csv(
      new.data,
      paste0(processed.data.path, new.data.name, ".csv"),
      na = "",
      row.names = FALSE
    )
    
  }



```

#### Dictionary

```{r}

if(class(ref.dictionary) == "list") {
  export.choice <- utils::select.list(
    c("tabular dictionary", "mdjson dictionary", "mdEditor file"),
    multiple = TRUE,
    graphics = TRUE,
    title = cat(paste0(
      "\nWhich format(s) would you like to export?\n"
    ))
  )
  
  if ("tabular dictionary" %in% export.choice) {
    message(cat(
      paste0(
        "\nProvide a name for the mdjson dictionary.\nThe mdjson record name is '",
        input.dxnry[["data"]][[1]][["meta"]][["title"]],
        "'.\n"
      )
    ))
    
    dxnry.name <- noquote(as.character(readline(prompt =)))
    
    if (dxnry.name == "") {
      dxnry.name <- input.dxnry[["data"]][[1]][["meta"]][["title"]]
    }
    
    dxnry.name <-  sub(" ", "_", dxnry.name)
    
    dxnry.name <- strsplit(gsub("[[:punct:]]$", "", dxnry.name), " +")[[1]]
    
    table.dxnry <- mdJSONdictio::build.table(input.dxnry)
    
    
    write.csv(
      table.dxnry,
      paste0(
        processed.data.path,
        dxnry.name,
        "_",
        format(
          as.POSIXct(input.dxnry[["data"]][[1]][["attributes"]][["date-updated"]], tz = "UTC", "%Y-%m-%dT%H:%M:%OS"),
          '%Y%m%d-%H%M%S'
        ),
        ".csv"
      ),
      na = "",
      row.names = FALSE
    )
    
  }
  
  if ("mdjson dictionary" %in% export.choice) {
    if (!"tabular dictionary" %in% export.choice) {
      message(cat(
        paste0(
          "\nProvide a name for the mdjson dictionary.\nThe mdjson record name is '",
          input.dxnry[["data"]][[1]][["meta"]][["title"]],
          "'.\n"
        )
      ))
      
      dxnry.name <- noquote(as.character(readline(prompt = )))
      
      if (dxnry.name == "") {
        dxnry.name <- input.dxnry[["data"]][[1]][["meta"]][["title"]]
      }
      
      dxnry.name <-  sub(" ", "_", dxnry.name)
      
      dxnry.name <- strsplit(gsub("[[:punct:]]$", "", dxnry.name), " +")[[1]]
      
    }
    
    new.dxnry <- rjson::toJSON(x = input.dxnry)
    
    write(
      x = new.dxnry,
      file = paste0(
        processed.data.path,
        dxnry.name,
        "_mdeditor-",
        format(
          as.POSIXct(input.dxnry[["data"]][[1]][["attributes"]][["date-updated"]], tz = "UTC", "%Y-%m-%dT%H:%M:%OS"),
          '%Y%m%d-%H%M%S'
        ),
        ".json"
      )
    )
    
  }
  
  if ("mdEditor file" %in% export.choice) {
    message(cat(
      paste0(
        "\nProvide a name for the mdjson file.
        \nThe current file name is '",
        gsub("\\_mdeditor.*", "", dxnry.filename, ignore.case = TRUE),
        "'.\n"
      )
    ))
    
    file.name <- noquote(as.character(readline(prompt = )))
    
    if (file.name == "") {
      file.name <-  gsub("\\_mdeditor.*", "", dxnry.filename, ignore.case = TRUE)
    }
    
    file.name <-  sub(" ", "_", file.name)
    file.name <- gsub('^[[:punct:]]|[[:punct:]]$', '', file.name)
    
    new.dxnry <- rjson::toJSON(x = ref.dictionary)
    
    write(
      x = new.dxnry,
      file = paste0(
        processed.data.path,
        file.name,
        "_mdeditor-",
        format(
          as.POSIXct(ref.dictionary[["data"]][[record.num]][["attributes"]][["date-updated"]], tz = "UTC", "%Y-%m-%dT%H:%M:%OS"),
          '%Y%m%d-%H%M%S'
        ),
        ".json"
      )
    )
    
  }
  
}

```

# Archive in the Regional Data Repository

```{r}
project = "mbmlb_004_Eielson"
path = "C:/Users/hvincelette/OneDrive - DOI/Documents/Data_management/landbirds_project_maintenance/Archived_Projects/Eielson"

```

```{r}
#
commit <-
  FWSAkRDRtools::commit.files(project = project,
               local.folder = path,
               recursive = TRUE)


```

# Create data packages

### Provide inputs

```{r}
# Provide a directory path for data file(s) to import
data.path <- "data-processed/to_archive/"

# Provide a directory path to write files
processed.data.path <- "data-processed/data_packages/Eielson_data_package_2024/"

# Provide versioning format, if applicable
vers.suffix <- "_v"

# Provide suffix for data files (i.e. year if filtering data)
data.suffix <- "_2024"

# Provide the relevant information (if applicable)
missing_values<- c(NA)
species.col <- "SpeciesCode"
date.col <- "Date"
date.format <-  "%m/%d/%Y"
time.col <- "CaptureTime_2400"
time.format <- "%H:%M"

```

### Import data

```{r}

data.list <- importer(
  path = data.path,
  multiple = TRUE,
  graphics = TRUE,
  column.format = list(
    c(column = date.col, format = date.format),
    c(column = time.col, format = time.format)
  )
)

metadata.list<- importer(
  path = data.path,
  multiple = TRUE,
  graphics = TRUE,
  column.format = list(
    c(column = date.col, format = date.format),
    c(column = time.col, format = time.format)
  )
)

```

### Filter data

```{r}

aou_code <- read.csv("reference/IBP-AOS-LIST23.csv", na = "")

## Translate species names/codes (if neccessary)
# 
# data.list <- data.list %>%
#   purrr::map(
#     .f = ~ .x %>%
#       dplyr::rename_with(., ~gsub('\\.', '', .x)) %>%
#       dplyr::inner_join(
#         .,
#         aou_code[, c("COMMONNAME", "SPEC")],
#         by = c("CommonName" = "COMMONNAME"),
#         keep = FALSE,
#         relationship = "many-to-many"
#       ) %>%
#       dplyr::mutate("SpeciesCode" = `SPEC`) %>%
#       dplyr::select(-"SPEC")
#   )

# Check species names/codes
data.list %>%
  purrr::map(.f = ~ .x %>%
               dplyr::filter(!.data[[species.col]] %in% aou_code$SPEC))


if(any(c(species.col, date.col) %in% unlist(purrr::map(data.list, colnames)))) {
  # Make filter selections
  if (species.col %in% unlist(purrr::map(data.list, colnames))) {
    species <- unique(unlist(sapply(data.list, "[", species.col)))
  } else {
    species<- character(0)
  }
  
  if (date.col %in% unlist(purrr::map(data.list, colnames))) {
    date.ranges <- data.list %>% purrr::map(
      .f = ~ .x %>%
        dplyr::select(all_of(date.col)) %>%
        dplyr::filter(.data[[date.col]] != "") %>%
        dplyr::mutate({{date.col}} := as.Date(.data[[date.col]], format = date.format))
      
      %>%
        append(list(
          "Min" = min(.[[date.col]]), "Max" = max(.[[date.col]])
        ))
    )
    
    dates.df <- data.list %>% purrr::map(
      .f = ~ .x %>%
        dplyr::select(all_of(date.col)) %>%
        dplyr::filter(.data[[date.col]] != "") %>%
        dplyr::mutate({{date.col}} := as.Date(.data[[date.col]], format = date.format))
    ) %>%
      dplyr::bind_rows(., .id = "id")
    
    min.date <- min(do.call("c", lapply(date.ranges, "[[", "Min")))
    max.date <- max(do.call("c", lapply(date.ranges, "[[", "Max")))
    
  } else {
    min.date <- as.Date("0001-01-01")
    max.date <- as.Date("0001-01-01")
  }


  filter.df.app(data.list, species.col, date.col, species, min.date, max.date)


# Apply filters
  id.var <- dplyr::last(make.names(c(unique(
    unlist(purrr::map(data.list, colnames))
  ), ".id"), unique = TRUE))
  
  data.list <- data.list %>%
    purrr::map(.f = ~ .x %>%
                 tibble::rowid_to_column(var = id.var))
  
  other.data.list <- data.list
  
  if (length(species) != 0) {
    data.list <- data.list %>%
      purrr::map(.f = ~ .x %>%
                   dplyr::filter(if_any(
                     matches(species.col), ~ .data[[species.col]] %in% selected.species
                   )))
  }
  
  
  if (min.date != "0001-01-01" |
      max.date != "0001-01-01") {
    data.list <- data.list %>%
      purrr::map(
        .f = ~ .x %>%
          dplyr::mutate_at(dplyr::vars(tidyselect::any_of(date.col)), as.Date, format = date.format) %>%
          dplyr::filter(if_any(
            matches(date.col),
            ~ data.table::between(.data[[date.col]], min(selected.dates), max(selected.dates), NAbounds =
                                    FALSE)
          ))
      )
  }
  
  rm.row <-  purrr::map(data.list, id.var)
  
  other.data.list <- lapply(seq_along(rm.row), function(i) {
    if (rlang::is_empty(rm.row[[i]]) == FALSE) {
      other.data.list[[i]] %>%
        dplyr::slice(-rm.row[[i]])
    } else {
      other.data.list[[i]]
    }
  }) %>%
    purrr::set_names(names(data.list))
  
    data.list <- purrr::map(data.list, ~ (.x %>% dplyr::select(-tidyselect::any_of(id.var))))
    
      other.data.list <- purrr::map(other.data.list, ~ (.x %>% dplyr::select(-tidyselect::any_of(id.var))))
   

# Remove empty dataframes
  data.list <- data.list %>%
    purrr::discard(., ~ nrow(.) == 0) %>%
    purrr::map(.f = ~ .x %>%
                 dplyr::mutate({{date.col}} := format(.data[[date.col]], format = date.format)))
  
  
  other.data.list <- other.data.list %>%
    purrr::discard(., ~ nrow(.) == 0) %>%
    purrr::map(.f = ~ .x %>%
                 dplyr::mutate({{date.col}} := format(.data[[date.col]], format = date.format)))
  
}

```

### Merge data

```{r}

if(length(data.list)>1) {
  # Make data frame selections
  merge.df.app(data.list)
  
  # Execute forced rbind
  if (is.null(selected.df) == FALSE) {
    data.list <-  c(list(merged_data = data.table::rbindlist(data.list[names(data.list) %in% selected.df], fill = TRUE)),
                        data.list[!names(data.list) %in% selected.df])
  }
  
  data.list <- data.list %>%
    purrr::map(
      .f = ~ .x %>%
        dplyr::mutate_if(is.character, ~ dplyr::na_if(., "")) %>%
        dplyr::mutate_if(is.character, ~ dplyr::na_if(., "NULL")) %>%
        dplyr::mutate_if(is.character, ~ dplyr::na_if(., missing_values))
    )
}

```

### Translate dictionaries

```{r}

dxnry.list <- list()

for (x in 1:length(metadata.list)) {
  if(is.data.frame(metadata.list[[x]])){
     dxnry.list[[x]] <- metadata.list[[x]]
     
  } else if (names(metadata.list[[x]]) == "data") {
    temp <-
      mdJSONdictio::extract.mdJSON(metadata.list[[x]], record.type = "dictionaries")
    
    names <- character(0)
    temp3 <- list()
    
    for (y in 1:length(temp[["data"]])) {
      temp2 <- list()
      
      temp2[["data"]][[1]] <- temp[["data"]][[y]]
      
      temp3[[y]] <- mdJSONdictio::build.table(temp2)
      
      names <- c(names, rjson::fromJSON(temp2[["data"]][[1]][["attributes"]][["json"]])[["dataDictionary"]][["citation"]][["title"]])
      
    }
    
    names(temp3) <- names
    
    dxnry.list[[x]] <- temp3
    
  }
}

names(dxnry.list)<- names(metadata.list)

```

### Export files

```{r}

fs::dir_create(names(which(!fs::dir_exists(processed.data.path))))
  
for(a in 1:length(data.list)) {
  write.csv(
    data.list[[a]],
    paste0(
      gsub("/$", "", processed.data.path),
      "/",
      gsub(paste0("(", vers.suffix, ").*"), "", names(data.list[a])),
      "_",
      gsub("^[^A-Za-z0-9]|[^A-Za-z0-9]$", "", data.suffix),
      ".csv"
    ),
    na = "",
    row.names = FALSE
  )
}

for(a in 1:length(dxnry.list)) {
  for(b in 1:length(dxnry.list[[a]])){
  write.csv(
    dxnry.list[[a]][[b]],
    paste0(
      gsub("/$", "", processed.data.path),
      "/",
      names(dxnry.list[[a]][b]),
      "_",
      format(Sys.time(), '%Y%m%d'),
      ".csv"
    ),
    na = "",
    row.names = FALSE
  )
  }
}




file.create(paste0(processed.data.path, "README.txt"), overwrite = TRUE)

sink(paste0(processed.data.path,"README.txt"))
cat(paste0("\nThis folder contains the following:\n\n"))

dirs <- list.dirs(processed.data.path,
                  recursive = TRUE,
                  full.names = FALSE)

for(a in 1:length(dirs)) {
  files <- basename(fs::dir_info(
    paste0(processed.data.path, dirs[a]),
    recurse = FALSE,
    type = "file"
  )$path)
  files<- files[!files =="README.txt"]
  
  if (length(files != 0)) {
   cat(paste0(dirs[a], "\n"), paste0(files, sep = "\n"))
    cat("\n")
  }
  
}

closeAllConnections()


```

# Publish to Science Base

# Capture data transformations

### Provide inputs

```{r}
# Provide a directory path for data file(s) to import
data.path <- "data-processed/to_archive/"

# Provide the relevant information (if applicable)
missing_values<- c(NA)
species.col <- "SpeciesCode"
date.col <- "Date"
date.format <-  "%m/%d/%Y"
time.col <- "CaptureTime_2400"
time.format <- "%H:%M"

```

### Import data

```{r}

data.list <- importer(
  path = data.path,
  multiple = TRUE,
  graphics = TRUE,
  column.format = list(
    c(column = date.col, format = date.format),
    c(column = time.col, format = time.format)
  )
)

```

### Filter data

```{r}

# Select data to transform
filter.option <- utils::select.list(
  c("by species", "by date range"),
  multiple = FALSE,
  graphics = TRUE,
  title = cat(
    paste0("\nHow do you want to filter the imported files?\n"),
    paste0(names(data.list), sep = "\n"),
    paste0("\nEnter 0 to review all data.\n")
  )
)

if (filter.option == "by species") {
  sp.vectors <- sapply(sapply(data.list, "[", species.col), unique)
  
  sp.overlap <- Reduce(intersect, sp.vectors)
  
  if (length(sp.overlap) == 0) {
    message(cat("A common species was not detected across imported files."))
  } else if (length(sp.overlap) > 0) {
    message(cat(
      paste0("The following species were detected in all imported files.\n"),
      paste0(sp.overlap, sp = "\n")
    ))
  }
  
  filter.choice <- utils::select.list(
    c(unique(unlist(sp.vectors))),
    multiple = TRUE,
    graphics = TRUE,
    title = cat(
      paste0(
        "\nSelect one or more species.\nUnselected species will be excluded from subsequent data processing.\n"
      )
    )
  )
  
  if (sum(sapply(temp, nrow)) == 0) {
    warning("Filter did not return results and will not be applied.")
    
  } else {
    data.list <- data.list %>%
      purrr::map(.f = ~ .x %>%
                   dplyr::filter(.data[[species.col]] %in% filter.choice))
  }
  
  
}


if (filter.option == "by date range") {
  date.ranges <- data.list %>% purrr::map(
    .f = ~ .x %>%
      dplyr::select(all_of(date.col)) %>%
      dplyr::filter(.data[[date.col]] != "") %>%
      dplyr::mutate({{date.col}} := as.Date(.data[[date.col]], format = date.format))
    
    %>%
      append(list(
        "Min" = min(.[[date.col]]), "Max" = max(.[[date.col]])
      ))
  )
  
  date.message <- c()
  
  for (a in 1:length(date.ranges)) {
    date.message[a] <-
      paste0(names(date.ranges[a]),
             ": ",
             date.ranges[[a]][["Min"]],
             " - ",
             date.ranges[[a]][["Max"]])
  }
  
  message(cat(
    paste0("The following date ranges were detected the imported files.\n"),
    paste0(date.message, sp = "\n")
  ))
  
  message(cat(
    paste0(
      "Provide start and end dates formatted as %Y-%m-%d (e.g., 2022-1-1).\nMissing and out of range dates will be excluded from subsequent data processing.\n"
    )
  ))
  
  
  start.date <- NA
  
  while (is.na(start.date)) {
    start.date.entry <- as.character(readline(prompt = "Start: "))
    
    if (is.na(as.Date(start.date.entry, format = "%Y-%m-%d"))) {
      message("\nError: Date incorrectly formatted.\n")
      
    } else {
      start.date <- as.Date(start.date.entry, format = "%Y-%m-%d")
    }
    
  }
  
  end.date <- NA
  
  while (is.na(end.date)) {
    end.date.entry <- as.character(readline(prompt = "End: "))
    
    if (is.na(as.Date(end.date.entry, format = "%Y-%m-%d"))) {
      message("\nError: Date incorrectly formatted.\n")
      
    } else {
      end.date <- as.Date(end.date.entry, format = "%Y-%m-%d")
    }
    
  }
  
  temp <- data.list %>%
    purrr::map(.f = ~ .x %>%
                 dplyr::mutate({{date.col}} := as.Date(.data[[date.col]], format = date.format))
               
               %>%
                 dplyr::filter(
                   data.table::between(.data[[date.col]], start.date, end.date, NAbounds =
                                         FALSE)
                 ))
  
  if (sum(sapply(temp, nrow)) == 0) {
    warning("Filter did not return results and will not be applied.")
    
  } else {
    data.list <- temp
    
    }
}

# Remove empty dataframes
data.list <- data.list %>%
  purrr::discard(., ~ nrow(.) == 0) %>%
  purrr::map(.f = ~ .x %>%
               dplyr::mutate({{date.col}} := format(.data[[date.col]], format = date.format)))

```

### Biological samples inventory

```{r}

# Provide directory path for the authoritative data file
download.path <- "data-processed/to_archive/"

# Provide a directory path to write processed files
processed.data.path <- "data-processed/to_archive/"

# Do you want to merge the data with an authoritative file?
auth.merge <- TRUE

# Provide versioning format (when merging with authoritative file)
vers.suffix <- "_v"

```

```{r}

# Prep data
cap.data <- plyr::ldply(data.list)

cap.data %>%
  tibble::as_tibble() %>%
  dplyr::filter(if_all(c("Date", "Year"), is.na))

cap.data <- cap.data %>%
  dplyr::mutate_at("BandNumberOut", ~ as.character(.)) %>%
  dplyr::mutate_if(is.character, ~ dplyr::na_if(., "")) %>%
  dplyr::mutate_if(is.character, ~ dplyr::na_if(., "NULL")) %>%
  dplyr::mutate_if(is.character, ~ dplyr::na_if(., missing_values)) %>%
  tidyr::drop_na(BandNumberOut, Year)


# Load reference tables
ref_data <-
  lapply(list.files(path = "reference/biosample_inventory/", full.names = TRUE),
         utils::read.csv, na.strings = "")

names(ref_data) <-
  gsub(
    list.files(path = "reference/biosample_inventory/"),
    pattern = ".csv$",
    replacement = ""
  )

list2env(ref_data, globalenv())


# Import authoritative data file
if (auth.merge == TRUE) {
  auth.data <- importer(
    path = download.path,
    multiple = FALSE,
    graphics = TRUE,
    column.format = list(
      c(column = date.col, format = date.format),
      c(column = time.col, format = time.format)
    )
  )
    

  auth.data <- auth.data %>%
    dplyr::mutate_at("BandNumber", ~ as.character(.)) %>%
    dplyr::mutate_if(is.character, ~ dplyr::na_if(., "")) %>%
    dplyr::mutate_if(is.character, ~ dplyr::na_if(., "NULL")) %>%
    dplyr::mutate_if(is.character, ~ dplyr::na_if(., missing_values))
  
  # Remove inventoried data
  cap.data <- cap.data %>%
    dplyr::anti_join(auth.data,
                     by = dplyr::join_by("BandNumberOut" == "BandNumber", "Year" == "YearCollected"))
  
}


```

#### Recode data

```{r}

# Correct colnames
cap.data <- cap.data %>%
  dplyr::rename_at(dplyr::vars(matches("Out$")), ~ stringr::str_remove(., "Out$")) %>%
  plyr::rename(
    replace = c(
      "Year" = "YearCollected",
      "Month" = "MonthCollected",
      "Day" = "DayCollected",
      "BanderID" = "Collector"
    )
  ) 
# %>%
# tidyr::unite("Feather",
#              c("FeatherType", "FeatherType1")[c("FeatherType", "FeatherType1") %in% names(cap.data)],
#              remove = TRUE,
#              na.rm = TRUE) %>%
# dplyr::mutate_at("Feather", ~ dplyr::na_if(., ""))

# Pivot sample columns

# Blood
  # c("BloodGenetics",
  # "BloodIsotope",
  # "BloodHg")
  
sample.cols <- c(
  "Feather",
  "AISwabO",
  "AISwabC",
  "Fecal",
  "Nails",
  "BloodFilter",
  "BloodCapTube",
  "BloodSmear"
)

cap.data <- cap.data %>%
  tidyr::pivot_longer(
    cols = tidyselect::any_of(sample.cols),
    names_to = "SampleType",
    values_to = "SampleTaken"
  ) %>%
  dplyr::mutate("FeatherType1" = ifelse(SampleType == "Feather", SampleTaken, NA)) %>%
  dplyr::mutate("SampleTaken" = ifelse(
    SampleType == "Feather" &
      is.na(FeatherType1) == FALSE,
    "Y",
    SampleTaken
  )) %>%
  dplyr::filter(SampleTaken %in% c("Y"))


```

#### Translate data

```{r}

# Auto fill sample details
cap.data<- cap.data %>%
  dplyr::left_join(.,sample_info,
                   by = "SampleType",
                   keep = FALSE,
                   relationship = "many-to-one")


# Add missing info
## OccurenceID

cap.data %>%
  dplyr::filter_at("SpeciesCode", is.na)

cap.data %>%
  dplyr::filter(if_all(c("StateProvince", "City", "Area"), is.na))


cap.data<- cap.data %>%
  dplyr::mutate(
    "StorageMethod" = "frozen",
    "StorageLocation" = "Alaska MBM",
    "SampleStatus" = NA,
    "Contact" = NA,
    "Notes" = NA
  )


```

#### Export data

```{r}

if(auth.merge==TRUE) {
  # Merge data
  new.data <- auth.data %>%
    merge(cap.data, all = TRUE) %>%
    dplyr::select(colnames(auth.data))

  # Versioning
  # detect.vers <- suppressWarnings(as.numeric(ifelse(
  #   grepl(paste0("\\", vers.suffix), auth.data.name, ignore.case = TRUE),
  #   sub(
  #     paste0(".*\\", vers.suffix),
  #     "",
  #     auth.data.name,
  #     ignore.case = TRUE
  #   ),
  #   ""
  # )))
  
  # if (is.na(detect.vers) == FALSE) {
  #   message(cat(
  #     paste0(
  #       "Provide a version number for the new authoritative data file.\nThe detected current version is '",
  #       detect.vers,
  #       "'."
  #     )
  #   ))
  # } else {
    message(cat(
      paste0(
        "Provide a version number for the new authoritative data file.\nA current version was not detected."
      )
    ))
  # }
  
  new.vers <-
    noquote(as.character(readline(prompt = )))
  
  if (new.vers != "") {
    new.vers <- paste0(vers.suffix, new.vers)
  }
  
  new.data.name <- paste0(sub(
    paste0("\\", vers.suffix, ".*"),
    "",
    auth.data.name,
    ignore.case = TRUE
  ), new.vers)
  
} else if (auth.merge == FALSE) {
  message(cat(paste0("\nProvide a name for the data file.\n")))
  
  new.data.name <- noquote(as.character(readline(prompt =)))
  
  new.data.name <-  sub(" ", "_", data.name)
  
  new.data.name <- strsplit(gsub("[[:punct:]]$", "", data.name), " +")[[1]]
  
}


write.csv(
  new.data,
  paste0(processed.data.path, new.data.name, ".csv"),
  na = "",
  row.names = FALSE
)


```

#### Update sample status

```{r}
# Provide the directory path to the sex results
file.path = "C:/Users/hvincelette/OneDrive - DOI/Documents/Fieldwork_wrap/2023/Sexing_Analysis/"
```

```{r}
# Import results
sex_results <- importer(path = file.path,
                        multiple = FALSE,
                        graphics = TRUE)


# Correct results
sex_results<- sex_results %>%
  dplyr::mutate_at("BandNumber", as.character) %>%
  tidyr::drop_na("OccurenceID") %>%
  dplyr::filter(Sex %in% c("F","M"))


# Check for duplicate results (creates duplicate rows in left_join)
sex_results[c(
  anyDuplicated(sex_results$BandNumber, fromLast = TRUE),
  anyDuplicated(sex_results$BandNumber, fromLast = FALSE)
), ]


# Join results
new.data <- new.data %>%
  dplyr::mutate(".id" = 1:nrow(.)) %>%
  dplyr::left_join(
    .,
    dplyr::distinct(sex_results[, c("SpeciesCode",
                                    "BandNumber",
                                    "YearCollected",
                                    "SampleTissue",
                                    "SampleForm",
                                    "Sex")]),
    by = c(
      "SpeciesCode",
      "BandNumber",
      "YearCollected",
      "SampleTissue",
      "SampleForm"
    ),
    keep = FALSE,
    relationship = "many-to-many"
  ) %>%
  dplyr::mutate_at(
    "SampleStatus",
    ~ dplyr::case_when(Sex %in% c("F", "M") ~ "analysis complete", TRUE ~ SampleStatus)
  ) %>%
  dplyr::select(-"Sex")


# # If status is out of sync..
# unanalyzed.index <- which(
#   new.data$Contact == "Sarah Sonsthagen" &
#     is.na(new.data$Sex) &
#     new.data$SpeciesCode != "REKN"
# ) 
# 
# new.data <- new.data %>%
#   dplyr::mutate_at("StorageMethod",
#             ~ dplyr::case_when(dplyr::row_number() %in% unanalyzed.index ~ "frozen", TRUE ~ .)) %>%
#   dplyr::mutate_at("StorageLocation",
#             ~ dplyr::case_when(dplyr::row_number() %in% unanalyzed.index ~ "Alaska MBM", TRUE ~ .)) %>%
#   dplyr::mutate_at("SampleStatus",
#             ~ dplyr::case_when(dplyr::row_number() %in% unanalyzed.index ~ NA, TRUE ~ .)) %>%
#    dplyr::mutate_at("Contact",
#             ~ dplyr::case_when(dplyr::row_number() %in% unanalyzed.index ~ NA, TRUE ~ .)) %>%
#     dplyr::select(-c("Sex",".id"))

  
write.csv(
  new.data,
  paste0(processed.data.path, new.data.name, ".csv"),
  na = "",
  row.names = FALSE
)

```

### Bander Portal

```{r}
# Provide a directory path to write processed files
processed.data.path <- "data-processed/bander_portal/"

```

```{r}

cap.data <- plyr::ldply(data.list)

# Reference tables
Master_Contacts <-
  read.csv(
    "~/Data_management/landbirds_project_maintenance/Reformatted_data/Master_Contacts.csv",
    na.strings = ""
  )

ref_data <-
  lapply(list.files(path = "reference/bander_portal/", full.names = TRUE),
         readxl::read_excel)

names(ref_data) <-
  gsub(
    list.files(path = "reference/bander_portal/"),
    pattern = ".xlsx$",
    replacement = ""
  )

list2env(ref_data, globalenv())


# Standardize missing values
cap.data <- cap.data %>%
  dplyr::mutate_if(is.character,  ~ dplyr::na_if(., "")) %>%
  dplyr::mutate_if(is.character,  ~ dplyr::na_if(., "NULL")) %>%
  dplyr::mutate_if(is.character,  ~ dplyr::na_if(., missing_values))

# Add missing columns
miss_cols <- setdiff(c(
  na.omit(capture_cols$my_col[!grepl("color", capture_cols$my_col)]),
  "TagType1",
  "TagType2",
  "TagStatus1",
  "TagStatus2"
),
colnames(cap.data))

cap.data[miss_cols] <-
  as.character(NA)

```

#### Recode data

```{r}

# How Obtained
recap.info <- cap.data %>%
  dplyr::filter(BBLDisposition == "R", !is.na(BBLCondition)) %>%
  dplyr::select(SpeciesCode, BBLDisposition, BBLCondition) %>%
  dplyr::distinct()

BBL_ref <-
  bander_portal_lookups %>%
  dplyr::filter(field == "How Obtained" &
                  status != "Discontinued") %>%
  dplyr::pull(code) %>%
  noquote() %>%
  unlist()

typical.num <- which(BBL_ref == "66")
  
  if (nrow(recap.info) != 0) {
    for (a in 1:nrow(recap.info)) {
      
    condition_desc <- bander_portal_lookups %>%
      dplyr::filter(field == "Bird/Band Condition" &
                      code == recap.info$BBLCondition[a]) %>%
      dplyr::pull(description) %>%
      unlist()
    
    obtained.choice <- 0
    while (obtained.choice == 0) {
      obtained.choice <-
        utils::menu(c(
          bander_portal_lookups %>%
            dplyr::filter(field == "How Obtained" &
                            status != "Discontinued") %>%
            dplyr::pull(description)
        ),
        title = cat(
          paste0(
            "\nThe bird/band condition of one or more recaptured ",
            recap.info$SpeciesCode[a] ,
            " was '",
            condition_desc,
            "'.\nHow were these birds obtained?\nSelect ",
            typical.num,
            " for typical recaptures (i.e., bird/band condition 'ALIVE - RELEASED/LEFT ON BIRD')\n"
          )
        ))
    }
    
    cap.data <- cap.data %>%
      dplyr::rowwise() %>%
      dplyr::mutate(
        "HowObtained" =
          ifelse(
            BBLDisposition == "R" &
              SpeciesCode == recap.info$SpeciesCode[a] &
              BBLCondition == recap.info$BBLCondition[a],
            BBL_ref[obtained.choice],
            
            HowObtained
          )
      )
    
  }
}

# Locations
loc.cols <- c("City", "Area")
loc.cols <- loc.cols[loc.cols %in% colnames(cap.data)]

cap.data <- cap.data %>%
  dplyr::mutate_at(
    dplyr::vars(which(names(.) %in% loc.cols)),
    ~ as.character(.) %>% dplyr::recode(
      .,
      "Eielson" = "EIEL",
      "Delta Junction" = "DELTA",
      "Eareckson" = "EARECK",
      "Beluga" = "BELUGA",
      "King Salmon" = "KING",
      "Nome" = "NOME",
      "Shemya" = "EARECK",
      "Anchorage" = "ANC",
      "Chicken" = "CHICKEN",
      "Fort Yukon" = "FORTYUK"
    )
  ) %>%
   dplyr::mutate(LocationID = dplyr::coalesce(!!!rlang::syms(loc.cols)))

BBL_locations <- c(
  "EIEL",
  "DELTA",
  "EARECK",
  "BELUGA",
  "KING",
  "NOME",
  "ANC",
  "JBER",
  "OTTER",
  "CHICKEN",
  "FORTYUK"
)

#!!# remove loc nums that correspond to the same locations
       
locs <- unique(cap.data$LocationID)[!unique(cap.data$LocationID) %in%
                                      BBL_locations]

for(a in locs) {
  loc.choice <-
    utils::menu(c(BBL_locations, "Enter a new location"),
                title = cat(
                  paste0(
                    "\n'",
                    a,
                    "' is not a listed BBL location ID.\nChoose an existing or new ID.\n"
                  )
                ))
  
  if (loc.choice == length(BBL_locations) + 1) {
    message(cat(
      paste0(
        "\nProvide a new location ID.\nThis will need to be added as a banding location in Bander Potal."
      )
    ))
    
    new_loc <-
      noquote(as.character(readline(prompt =)))
    
    
  } else {
    new_loc <- BBL_locations[loc.choice]
  }
  
  if (new_loc != "") {
    if (is.na(a)) {
      cap.data <-  cap.data %>%
        dplyr::mutate_at("LocationID",
                         ~ replace(.,
                                   is.na(.), new_loc))
    } else {
      cap.data <-  cap.data %>%
        dplyr::mutate_at("LocationID",
                         ~ replace(.,
                                   . == a, new_loc))
    }
  }
}

# Capture method
cap.data <- cap.data %>%
  dplyr::mutate_at(
    "CaptureMethod",
    ~ as.character(.) %>%
      dplyr::recode(
        .,
        "MN" = "Mist net",
        "WT" = "Walk-in trap",
        "HA" = "Hand capture",
        "BN" = "Bow net",
        "CN" = "Cannon net",
        "WN" = "Whoosh net",
        "NG" = "Net guns"
      )
  )

# Bander/Scribe ID
cap.data <- cap.data %>%
  dplyr::mutate_at(
    c("BanderID", "ScribeID"),
    ~ as.character(.) %>% plyr::mapvalues(
      .,
      from = Master_Contacts$FWSCode_FMLast,
      to = Master_Contacts$FWSCode_FML,
      warn_missing = FALSE
    )
  ) %>%
  dplyr::mutate_at(
    c("BanderID", "ScribeID"),
    ~ plyr::mapvalues(
      .,
      from = Master_Contacts$FWSCode_FLast,
      to = Master_Contacts$FWSCode_FL,
      warn_missing = FALSE
    )
  )

# Sex
cap.data <- cap.data %>%
  dplyr::mutate_at("FieldSex", ~ as.character(.)) %>%
  dplyr::rowwise() %>%
  dplyr::mutate_at("FieldSex",
                   ~ ifelse(
                     BBLDisposition == "R",
                     dplyr::recode(., "M" = "6", "F" = "7", "U" = "0"),
                     dplyr::recode(., "M" = "4", "F" = "5", "U" = "0")
                   ))


# Molt
cap.data <- cap.data %>%
  dplyr::mutate_at(
    "BodyMolt",
    ~ as.character(.) %>% dplyr::recode(
      .,
      "0" = "N",
      "1" = "Y",
      "2" = "Y",
      "3" = "Y",
      "4" = "Y"
    )
  ) %>%
  dplyr::mutate_at(
    "FlightFeatherMolt",
    ~ as.character(.) %>% dplyr::recode(
      .,
      "N" = "N",
      "S" = "Y",
      "A" = "Y",
      "J" = "Y"
    )
  )


# Leg attachments
leg_cols <-   c(
  "ULIn",
  "LLIn",
  "URIn",
  "LRIn",
  "ULOut",
  "LLOut",
  "UROut",
  "LROut"
)

leg_cols <- leg_cols[leg_cols %in% colnames(cap.data)]

color_cols<- paste0(leg_cols,"_colorband")


# test <- cap.data %>%
#   dplyr::filter_at(leg_cols, dplyr::any_vars(stringr::str_detect(., stringr::regex("-", ignore_case =
#                                                                                      TRUE))))

my_colors <-
  c(
    "Bk",
    "Br",
    "Db",
    "Lb",
    "Mb",
    "Dg",
    "Lg",
    "Gy",
    "Hp",
    "Mg",
    "Mv",
    "Or",
    "Pp",
    "Rd",
    "Wh",
    "Yl"
  )

BBL_colors <-
  c(
    "Black",
    "Brown",
    "Dark Blue",
    "Light Blue",
    "Blue",
    "Dark Green",
    "Light Green",
    "Gray",
    "Hot Pink",
    "Magenta",
    "Mauve",
    "Orange",
    "Purple",
    "Red",
    "White",
    "Yellow"
  )

cap.data <-  cap.data %>%
  dplyr::mutate_if(is.logical, as.factor) %>%
  dplyr::rowwise() %>%
  dplyr::mutate_at(
    c(leg_cols, "FlagColorIn", "FlagColorOut",  "FlagCodeColorIn", "FlagCodeColorOut"),
    ~ stringi::stri_replace_all_fixed(.,
                                      my_colors,
                                      BBL_colors,
                                      vectorize_all = FALSE)) %>%
  dplyr::mutate_at(leg_cols,
                   ~ stringi::stri_replace_all_fixed(.,
                                                     "-",
                                                     "/",
                                                     vectorize_all = FALSE)) %>%
  dplyr::mutate(across(.cols = all_of(leg_cols),
                       .names = "{paste0(color_cols[!grepl('Flag', color_cols)])}")) %>%
  dplyr::mutate_at(
    leg_cols,
    ~ stringi::stri_replace_all_fixed(.,
                                      BBL_colors,
                                      "01A",
                                      vectorize_all = FALSE)) %>%
  dplyr::mutate_at(leg_cols,
                   ~ stringi::stri_replace_all_fixed(.,
                                                     c("X", "Flag"),
                                                     c("00", "69"),
                                                     vectorize_all = FALSE)) %>%
  dplyr::mutate_at(
    color_cols,
    ~ ifelse(
      grepl("/", .),
      stringi::stri_replace_all_fixed(.,
                                      c("X", "Geo", "Flag"),
                                      "", vectorize_all = FALSE),
      stringi::stri_replace_all_fixed(.,
                                      c("X", "Geo", "Flag"),
                                      NA, vectorize_all = FALSE)
    )) %>%
  dplyr::mutate_at(color_cols,
                   ~ ifelse(
                     grepl("/$|.*/", .),
                     stringi::stri_replace_all_fixed(.,
                                                     "/",
                                                     "", vectorize_all = FALSE),
                     .
     
              ))


# ## Flag code colors by species - new/retained/replaced
# flag_info <- cap.data %>%
#   dplyr::filter(dplyr::if_any(c(leg_cols),
#                               ~ stringr::str_detect(., "69")))  %>%
#   dplyr::rowwise() %>%
#   dplyr::mutate(
#     FlagCodeChange = ifelse(FlagCodeIn != FlagCodeOut, 1, 0),
#     FlagIn = ifelse(is.na(FlagCodeIn) == FALSE, 1, 0),
#     FlagOut = ifelse(is.na(FlagCodeOut) == FALSE, 1, 0)
#   ) %>%
#   dplyr::select(any_of(c(
#     "SpeciesCode", "FlagIn", "FlagOut", "FlagCodeChange"
#   ))) %>%
#   dplyr::distinct() %>%
#   dplyr::mutate_all(as.character) %>%
#   dplyr::mutate_at("FlagCodeChange", ~ replace(., is.na(.), 0))
# 
# BBL_ref <- bander_portal_lookups$code[bander_portal_lookups$field ==
#                                         "Marker color"]
# BBL_ref<- BBL_ref[!grepl("/", BBL_ref)]
# 
# cap.data[, "FlagCodeIn_color"] <- NA
# cap.data[, "FlagCodeOut_color"] <- NA
# 
# if(nrow(flag_info)!=0) {
#   for (b in 1:nrow(flag_info)) {
#     flag_status <-
#       ifelse(flag_info$FlagIn[b] == 0,
#              "received a new",
#              "were recaptured with a")
#     
#     flag_status <-
#       ifelse(flag_info$FlagCodeChange[b] == 0,
#              flag_status,
#              "received a replacement")
#     
#     flag_status.2 <-
#       ifelse(flag_info$FlagCodeChange[b] == 0, "", "original ")
#     
#     
#     flag.choice <- 0
#     while (flag.choice == 0) {
#       flag.choice <-
#         utils::menu(c(BBL_ref), title = cat(
#           paste0(
#             "\nOne or more ",
#             flag_info$SpeciesCode[b] ,
#             " ",
#             flag_status,
#             " flag.\nWhat is the ",
#             flag_status.2 ,
#             "flag code color?\n"
#           )
#         ))
#     }
#     
#     if (flag_info$FlagIn[b] == 0) {
#       ### new
#       cap.data$FlagCodeOut_color[cap.data$SpeciesCode == flag_info$SpeciesCode[b] &
#                                    is.na(cap.data$FlagCodeIn) &
#                                    !is.na(cap.data$FlagCodeOut)] <-
#         BBL_ref[flag.choice]
#     } else {
#       if (flag_info$FlagCodeChange[b] == 1) {
#         flag.choice.2 <- 0
#         while (flag.choice.2 == 0) {
#           flag.choice.2 <-
#             utils::menu(c(BBL_ref), title = cat(paste0(
#               "\nWhat is the new flag code color?\n"
#             )))
#         }
#         
#         ### replaced
#         cap.data$FlagCodeIn_color[cap.data$SpeciesCode == flag_info$SpeciesCode[b] &
#                                     !is.na(cap.data$FlagCodeIn) &
#                                     cap.data$FlagCodeIn != cap.data$FlagCodeOut &
#                                     !is.na(cap.data$FlagCodeOut)] <-
#           BBL_ref[flag.choice]
#         
#         cap.data$FlagCodeOut_color[cap.data$SpeciesCode == flag_info$SpeciesCode[b] &
#                                      !is.na(cap.data$FlagCodeIn) &
#                                      cap.data$FlagCodeIn != cap.data$FlagCodeOut &
#                                      !is.na(cap.data$FlagCodeOut)] <-
#           BBL_ref[flag.choice.2]
#         
#       } else {
#         ### retained
#         cap.data$FlagCodeIn_color[cap.data$SpeciesCode == flag_info$SpeciesCode[b] &
#                                     !is.na(cap.data$FlagCodeIn) &
#                                     cap.data$FlagCodeIn == cap.data$FlagCodeOut] <-
#           BBL_ref[flag.choice]
#         
#         cap.data$FlagCodeOut_color[cap.data$SpeciesCode == flag_info$SpeciesCode[b] &
#                                      !is.na(cap.data$FlagCodeIn) &
#                                      cap.data$FlagCodeIn == cap.data$FlagCodeOut] <-
#           BBL_ref[flag.choice]
#       }
#       
#     }
#   }
# }


# Tags
tag_types <- c("Geo", "Radio", "GPS", "PTT")
tag_info <- cap.data %>%
  dplyr::filter_at(c("TagType1", "TagType2"),
                   dplyr::any_vars(stringr::str_detect(
                     ., stringr::regex(paste(tag_types, collapse = '|'), ignore_case =
                                         TRUE)
                   ))) %>%
  tidyr::pivot_longer(cols = starts_with("TagType"),
                      names_to = "TagType.col",
                      values_to = "TagType") %>%
  tidyr::pivot_longer(
    cols = starts_with("TagStatus"),
    names_to = "TagStatus.col",
    values_to = "TagStatus"
  ) %>%
  dplyr::filter(readr::parse_number(TagStatus.col) == readr::parse_number(TagType.col)) %>%
  dplyr::filter(!is.na(TagType)) %>%
  dplyr::select(SpeciesCode,
                TagType,
                TagStatus) %>%
  dplyr::distinct()

if(nrow(tag_info)!=0){
  for(a in 1:nrow(tag_info)) {
    BBL_tags <-
      unlist(strsplit(capture_recode$BBL_code[capture_recode$my_code == tag_info$TagType[a]], ","))
    
    BBL_ref <- bander_portal_lookups %>%
      dplyr::filter(field == "Marker Type", code %in% BBL_tags) %>%
      dplyr::pull(description) %>%
      stringr::str_extract_all("(?<=\\().+?(?=\\))") %>%
      unlist()
    
    tag.choice <- 0
    while (tag.choice == 0) {
      tag.choice <-
        utils::menu(c(BBL_ref), title = cat(
          paste0(
            "\nA ",
            tolower(tag_info$TagType[a]),
            " tag was ",
            tolower(tag_info$TagStatus[a]),
            " on one or more ",
            tag_info$SpeciesCode[a],
            ".\nHow was this marker attached?\n"
          )
        ))
    }
    
    cap.data <- cap.data %>%
      dplyr::rowwise() %>%
      dplyr::mutate_at(
        c(leg_cols, "TagType1"),
        ~ ifelse(
          !is.na(TagType1) &
            SpeciesCode == tag_info$SpeciesCode[a] &
            TagStatus1 == tag_info$TagStatus[a],
          stringi::stri_replace_all_regex(., tag_info$TagType[a], BBL_tags[tag.choice], vectorize_all = FALSE),
          
          .
        )
      ) %>%
      dplyr::mutate_at(
        c(leg_cols, "TagType2"),
        ~ ifelse(
          !is.na(TagType2) &
            SpeciesCode == tag_info$SpeciesCode[a] &
            TagStatus2 == tag_info$TagStatus[a],
          stringi::stri_replace_all_regex(., tag_info$TagType[a], BBL_tags[tag.choice], vectorize_all = FALSE),
          .
        )
      )
  }
}


```

#### Quality checks

```{r}

# Species measurements
if(class(bander_portal_species_measurements$bandSize)!= "list") {
  bander_portal_species_measurements <-
    bander_portal_species_measurements %>%
    dplyr::mutate_if(is.numeric, ~ dplyr::na_if(., 0)) %>%
    dplyr::rowwise() %>%
    dplyr::mutate_at("bandSize", ~ ifelse(grepl(", ", .), as.list(strsplit(., ", ")), as.list(.)))
}


mydata_col <- c("Mass_g", "Wing_mm", "Tail_mm")
BBL_col <-
  c(
    "femaleMass_min_g",
    "femaleMass_max_g",
    "maleMass_min_g",
    "maleMass_max_g",
    "femaleWingChord_min_mm",
    "femaleWingChord_max_mm",
    "maleWingChord_min_mm",
    "maleWingChord_max_mm",
    "femaleTailLength_min_mm",
    "femaleTailLength_max_mm",
    "maleTailLength_min_mm",
    "maleTailLength_max_mm"
  )

for (x in unique(cap.data$SpeciesCode)) {
  species.num <-
    which(bander_portal_species_measurements$alphaCode == x)
  if (length(species.num) == 0) {
    warning(paste0("SpeciesCode '", x, "' is invalid."))
  } else {
    sp_mydata <- cap.data %>%
      dplyr::filter(SpeciesCode == x) %>%
      dplyr::rowwise() %>%
      dplyr::mutate_at("FieldSex",
                       ~ dplyr::recode(
                         .,
                         "4" = "M",
                         "5" = "F",
                         "6" = "M",
                         "7" = "F" ,
                         "0" = "U"
                       ))
    
    sp_BBLdata <- bander_portal_species_measurements %>%
      dplyr::filter(alphaCode == x)
    
    ### Band size
    if (length(setdiff(unique(na.omit(
      sp_mydata$BandSize
    )), unlist(na.omit(
      sp_BBLdata$bandSize
    ))))
    != 0) {
      warning(
        paste0(
          "One or more ",
          sp_BBLdata$commonName,
          " has a band size inconsistent with BBL recommendations."
        )
      )
    }
    
    ## Mass/Wing chord/Tail
    for (a in c("Mass", "Wing", "Tail")) {
      for (b in  c("F", "M", "U")) {
        for (c in c("min", "max")) {
          mydata_col.match <- mydata_col[grep(a, mydata_col)]
          
          if (b == "U") {
            BBL_col.match <-
              BBL_col[grepl(a, BBL_col) & grepl(c, BBL_col)]
            sex_code <- c("U", NA)
            sex <- "unknown sex"
            
          } else {
            BBL_col.match <-
              BBL_col[grepl(a, BBL_col) &
                        grepl(paste0("^", b), BBL_col, ignore.case = TRUE) &
                        grepl(c, BBL_col)]
            sex_code <-  b
            sex <-
              grep(
                paste0("^", b),
                c("female", "male"),
                ignore.case = TRUE,
                value = TRUE
              )
            
          }
          fun <- match.fun(c)
          sign <- c("<", ">")[grep(c, c("min", "max"))]
          comparative <-
            c("smaller", "greater")[grep(c, c("min", "max"))]
          measurement <-
            c("mass", "wing chord", "tail")[grep(a, c("Mass", "Wing", "Tail"))]
          
          
          if (is.na(sum(sp_BBLdata[which(colnames(sp_BBLdata) %in% BBL_col.match)])) == FALSE) {
            if (length(na.omit(sp_mydata[[mydata_col.match]][sp_mydata$FieldSex %in% sex_code])) !=
                0) {
              if (get(sign)(fun(sp_BBLdata[which(colnames(sp_BBLdata) %in% BBL_col.match)]), fun(na.omit(sp_mydata[[mydata_col.match]][sp_mydata$FieldSex %in% sex_code]))) ==
                  FALSE)
              {
                {
                  warning(
                    paste0(
                      "One or more ",
                      sp_BBLdata$commonName,
                      " (",
                      sex,
                      ") have a ",
                      comparative,
                      " ",
                      measurement,
                      " than expected for the species (",
                      c,
                      ": ",
                      fun(sp_BBLdata[which(colnames(sp_BBLdata) %in% BBL_col.match)]),
                      " ",
                      sub('.*\\_', '', BBL_col.match[1]),
                      ")"
                    )
                  )
                }
              }
            }
          }
        }
      }
    }
  }
}


# lookup tables

lookups <- c("Age",
             "Sex",
             "How Aged",
             "How Sexed",
             "Marker Type",
             "Marker color")

for (a in lookups) {
  b <- which(capture_cols$BBL_col[capture_cols$BBL_template=="band_aux"] == a)
  for (c in b) {
    invalid.num <-
      which(!na.omit(cap.data[[capture_cols$my_col[c]]]) %in% bander_portal_lookups$code[bander_portal_lookups$field == a])
    
    invalid.index <-
      setdiff(1:nrow(cap.data), which(is.na(cap.data[[capture_cols$my_col[c]]])))[invalid.num]
    
    entry.skip <- c()
    
    if (length(invalid.index) != 0) {
      for (d in invalid.index) {
        if (d %in% entry.skip) {
          next
        } else{
          entry.choice <-
            utils::menu(c("replace these entries",
                          "do nothing"),
                        title = cat(
                          paste0(
                            "\n'",
                            cap.data[[capture_cols$my_col[c]]][d],
                            "' (",
                            capture_cols$my_col[c],
                            ") is not listed as a BBL ",
                            a,
                            "\nHow would you like to proceed?"
                          )
                        ))
          
          descriptions <- bander_portal_lookups$description[bander_portal_lookups$field == a]
          if (all(is.na(descriptions))) {
            descriptions <- ""
          } else {
            descriptions<- paste0(" - ", descriptions)
          }
          
          if (entry.choice == 1) {
            replace.choice <-
              utils::menu(c(
                paste0(
                  bander_portal_lookups$code[bander_portal_lookups$field == a],
                  descriptions
                )
              ),
              title = cat(paste0(
                "\nChoose a replacement value."
              )))
            
            if (replace.choice != 0) {
              entry.skip <- c(entry.skip,
                              which(cap.data[[capture_cols$my_col[c]]] == cap.data[[capture_cols$my_col[c]]][d]))
              
              cap.data[[capture_cols$my_col[c]]] <-
                replace(cap.data[[capture_cols$my_col[c]]],
                        cap.data[[capture_cols$my_col[c]]] %in% cap.data[[capture_cols$my_col[c]]][d],
                        bander_portal_lookups$code[bander_portal_lookups$field == a][replace.choice])
            }
            
          } else if (entry.choice == 2) {
            entry.skip <- c(entry.skip, which(cap.data[[capture_cols$my_col[c]]] == cap.data[[capture_cols$my_col[c]]][d]))
          }
        }
      }
    }
  }
}

# Bird status
## Status codes
status_info <- cap.data %>%
  dplyr::rowwise() %>%
  dplyr::mutate_at("TagType1", ~ ifelse(TagStatus1 %in% c("Removed", "Lost"), TagType1 <-
                                          NA
                                        , .)) %>%
  dplyr::mutate_at("TagType2", ~ ifelse(TagStatus2  %in% c("Removed", "Lost"), TagType2 <-
                                          NA
                                        , .)) %>%
  dplyr::select(
    "OccurenceID",
    "BandNumberOut",
    "SpeciesCode",
    "BBLStatus",
    leg_cols[grepl("Out", leg_cols)],
    "TagType1",
    "TagType2",
    "Blood",
    "BBLStatus"
  ) %>%
  dplyr::mutate_at(dplyr::vars(c(
    leg_cols[grepl("Out", leg_cols)], "TagType1", "TagType2", "BBLStatus"
  )), ~as.character(.) %>% dplyr::na_if(.,"")) %>%
  dplyr::mutate(NumMarkers = sum(!unique(dplyr::c_across(
    c(leg_cols[grepl("Out", leg_cols)], "TagType1", "TagType2")
  ))  %in% c("00", NA))) %>%
  dplyr::mutate_at(
    "BBLStatus",
    ~ dplyr::case_when(
      NumMarkers >= 2 &
        Blood != "Y" ~ "325",
      NumMarkers >= 1 &
        Blood == "Y" ~ "319",
      NumMarkers == 0 &
        Blood == "Y" ~ "318",
      NumMarkers == 0 &
        Blood != "Y" ~ "300",
      NumMarkers == 1 &
        dplyr::if_any(c(leg_cols[grepl("Out", leg_cols)], "TagType1", "TagType2"), ~
                        . == "69") &
        Blood != "Y" ~ "369",
      NumMarkers == 1 &
        dplyr::if_any(c(leg_cols[grepl("Out", leg_cols)], "TagType1", "TagType2"), ~
                        grepl("^81", .)) &
        Blood != "Y" ~ "381",
      NumMarkers == 1 &
        dplyr::if_any(c(leg_cols[grepl("Out", leg_cols)], "TagType1", "TagType2"), ~
                        grepl("^80", .)) &
        Blood != "Y" ~ "380",
      NumMarkers == 1 &
        dplyr::if_any(c(leg_cols[grepl("Out", leg_cols)], "TagType1", "TagType2"), ~
                        grepl("^90", .)) &
        Blood != "Y" ~ "390",
      NumMarkers == 1 &
        dplyr::if_any(c(leg_cols[grepl("Out", leg_cols)], "TagType1", "TagType2"), ~
                        grepl("^01", .)) &
        Blood != "Y" ~ "301",
      TRUE ~ BBLStatus
    )
  ) %>%
  dplyr::rename(`temp:BBLStatus` = BBLStatus)

cap.data <- cap.data %>%
  dplyr::left_join(
    .,
    status_info[, c("OccurenceID", "temp:BBLStatus")],
    by = c("OccurenceID" = "OccurenceID"),
    keep = FALSE,
    relationship = "one-to-one"
  ) %>%
  dplyr::mutate_at("BBLStatus", ~ as.character(.))

invalid.index <- which(cap.data$BBLStatus != cap.data$`temp:BBLStatus`)


if (length(invalid.index) != 0) {
  for (a in invalid.index) {
    message(cat(
      paste0(
        "The status for the following individual appears invalid.\nSpecies: ",
        cap.data$SpeciesCode[a],
        "\nBand number: ",
        cap.data$BandNumberOut[a],
        "\nStatus (reported): ",
        cap.data$BBLStatus[a],
        " [",
        bander_portal_lookups$description[grepl(stringr::str_sub(cap.data$BBLStatus[a], 1, 1),
                                                bander_portal_lookups$code) == TRUE &
                                            bander_portal_lookups$field == "Bird Status"],
        " ",
        bander_portal_lookups$description[grepl(stringr::str_sub(cap.data$BBLStatus[a], 2, 3),
                                                bander_portal_lookups$code) == TRUE &
                                            bander_portal_lookups$field == "Bird Status Extra Info"],
        "]",
        "\nStatus (detected): ",
        cap.data$`temp:BBLStatus`[a],
        " [",
        bander_portal_lookups$description[grepl(
          stringr::str_sub(cap.data$`temp:BBLStatus`[a], 1, 1),
          bander_portal_lookups$code
        ) == TRUE &
          bander_portal_lookups$field == "Bird Status"],
        " ",
        bander_portal_lookups$description[grepl(
          stringr::str_sub(cap.data$`temp:BBLStatus`[a], 2, 3),
          bander_portal_lookups$code
        ) == TRUE &
          bander_portal_lookups$field == "Bird Status Extra Info"],
        "]",
        "\nBlood: ",
        cap.data$Blood[a],
        "\nULOut: ",
        cap.data$ULOut[a],
        "\nLLOut: ",
        cap.data$LLOut[a],
        "\nUROut: ",
        cap.data$UROut[a],
        "\nLROut: ",
        cap.data$LROut[a],
        "\nTagStatus1: ",
        cap.data$TagStatus1[a],
        "\nTagStatus2: ",
        cap.data$TagStatus2[a]
      )
    ))
    
    status.choice <- utils::menu(
      choice = c("update as detected", "manually edit", "leave as is"),
      graphics = TRUE,
      title = cat("\nHow would you like to proceed?\n")
    )
    
    if (status.choice == 1) {
      cap.data$BBLStatus[a] <- cap.data$`temp:BBLStatus`[a]
      
      
    }
    if (status.choice == 2) {
      message(
        "\nIMPROTANT: you must click 'syncronise' (arrow loop icon) and then 'Done' to enact changes."
      )
      
      invalid.entries <- cap.data %>%
        dplyr::ungroup() %>%
        dplyr::filter(dplyr::row_number() == a)
      
      invalid.entries.edit <-
        DataEditR::data_edit(
          invalid.entries,
          col_readonly = colnames(invalid.entries)[!colnames(invalid.entries) %in% "BBLStatus"],
          viewer = "pane"
        ) %>%
        dplyr::mutate_at("BBLStatus", as.character)
      
      cap.data[match(invalid.entries.edit$OccurenceID,
                     cap.data$OccurenceID), "BBLStatus"] <-
        invalid.entries.edit$BBLStatus
    }
    
  }
}


cap.data <-
  cap.data %>%
  dplyr::select(-tidyselect::starts_with("temp:"))


# Other
## Band number
for(a in c("In", "Out")) {
  invalid_code.num <-
    which(!c(nchar(na.omit(
      gsub("-", "", cap.data[[paste0("BandNumber", a)]])
    ))) %in% c(8, 9))
  
  dir <-
    c("incoming", "outgoing")[grep(a, c("BandNumberIn", "BandNumberOut"))]
  
  if (length(invalid_code.num) != 0) {
    warning(
      paste0(
        "The following ",
        dir,
        " band numbers appear invalid. BBL issued federal metal bands should have 8 or 9 digits.\n"
      ),
      paste0(na.omit(cap.data[[paste0("BandNumber", a)]])[invalid_code.num], sep = "\n")
    )
  }
}

invalid_bands <- cap.data %>%
  dplyr::group_by(BandNumberOut, BBLDisposition) %>%
  dplyr::filter(BBLDisposition == "1",
                dplyr::n() > 1)

for(a in unique(invalid_bands$BandNumberOut)) {
  unique(invalid_bands$SpeciesCode[invalid_bands$BandNumberOut == a])
  warning(
    paste0(
      "Band number ",
      a,
      " is duplicated for the following species/flag codes.\n"
    ),
    paste0(
      paste0(
        invalid_bands$SpeciesCode[which(invalid_bands$BandNumberOut == a)],
        " (",
        invalid_bands$FlagCodeOut[which(invalid_bands$BandNumberOut == a)],
        ")"
      ),
      sep = "\n"
    )
  )
}

## Date
if(NA %in% cap.data$Day |
   NA %in% cap.data$Month |
   NA %in% cap.data$Year) {
  if ("Date" %in% colnames(cap.data)) {
    if (!NA %in% suppressWarnings(chron::chron(cap.data$Date, format = gsub("%", "",date.format)))) {
      
      date.choice <-
        utils::menu(c("please do", "absolutely not"),
                    title = cat(
                      paste0(
                        "\nThe variables Day, Month, and/or Year are incomplete. Would you like to parse this information from Date?\n"
                      )
                    ))
    
      if(date.choice==1) {
        cap.data <-
          cap.data %>%
          dplyr::mutate(
            Date = as.Date(Date, date.format),
            Day = lubridate::day(Date),
            Month = lubridate::month(Date),
            Year = lubridate::year(Date)
          )
      }
    } else {
      warning("The variables Day, Month, and/or Year are incomplete.")
    }
  } else {
    warning("The variables Day, Month, and/or Year are incomplete.")
  }
}

## Time
time.num <-
  which(is.na(lubridate::hm(cap.data$CaptureTime_2400, quiet = TRUE)) |
          grepl("[A-Za-z]", cap.data$CaptureTime_2400) == TRUE)

if (length(time.num) != 0) {
  warning(
    paste0(
      "One or more time entries (CaptureTime_2400) are invalid. Time must be formatted as 24:00.\n"
    ),
    paste0(unique(cap.data$CaptureTime_2400[time.num]), sep = "\n")
  )
}

              
## Bander ID/Scribe ID
for (a in c("BanderID", "ScribeID")) {
  invalid_code.num <- which(nchar(unique(cap.data[[a]])) > 3)
  
  for (b in invalid_code.num) {
    message(cat(
      paste0(
        "'",
        unique(cap.data[[a]])[b],
        "' (",
        a,
        ") appears invalid.\nProvide a replacement value. Press Enter to retain the current value."
      )
    ))
    
    new_code <-
      noquote(as.character(readline(prompt =)))
    
    if (new_code != "") {
      cap.data <-  cap.data %>%
        dplyr::mutate_at(c("BanderID", "ScribeID"),
                         ~ replace(., . == unique(cap.data[[a]])[b], new_code))
    }
  }
}

```

#### Translate data

```{r}

# Partition by disposition
cap.data_aux <-
  cap.data %>% dplyr::filter(dplyr::if_any(leg_cols, ~ !. %in% c(NA, "00")))

cap.data_no_aux <-
  cap.data %>% dplyr::filter(dplyr::if_all(leg_cols, ~ . %in% c(NA, "00")))

cap.data_aux <- split(cap.data_aux, cap.data_aux$BBLDisposition)
cap.data_no_aux <- split(cap.data_no_aux, cap.data_no_aux$BBLDisposition)

#!!# Improve process for no data
#!!# 8 just reports band number in band_no_aux
for (a in c("cap.data_aux", "cap.data_no_aux")) {
  for (b in c("1", "R")) {
    if (!b %in% names(eval(as.name(a)))) {
      temp <-  list(rbind(tibble::as_tibble(
        matrix(
          ncol = length(cap.data),
          nrow = 1,
          dimnames = list(NULL, colnames(cap.data))
        ), check.names = FALSE
      )))
      
      names(temp) <- b
      
      temp<- c(eval(as.name(a)),temp)
      
      assign(a, temp)
      
    }
  }
}


# Merge 1, 5, 8, & F dispositions
cap.data_no_aux$'1' <-
  tibble::as_tibble(data.table::rbindlist(cap.data_no_aux[c('1', '5', '8')]))
cap.data_no_aux <- suppressWarnings(within(cap.data_no_aux, rm('5','8')))

cap.data_aux$'1' <-
  tibble::as_tibble(data.table::rbindlist(cap.data_aux[c('1', '5', '8')]))
cap.data_aux <- suppressWarnings(within(cap.data_aux, rm('5', '8')))

cap.data_no_aux$'R' <-
  tibble::as_tibble(data.table::rbindlist(cap.data_no_aux[c('R', 'F')]))
cap.data_no_aux <- suppressWarnings(within(cap.data_no_aux, rm('F')))

cap.data_aux$'R' <-
  tibble::as_tibble(data.table::rbindlist(cap.data_aux[c('R', 'F')]))
cap.data_aux <- suppressWarnings(within(cap.data_aux, rm('F')))

## Correct variable classes
cap.data_aux <- lapply(cap.data_aux, function(x) {
  x %>%
    dplyr::mutate_if(is.character, ~ dplyr::na_if(., ''))
})
cap.data_no_aux <- lapply(cap.data_no_aux, function(x) {
  x %>%
    dplyr::mutate_if(is.character, ~ dplyr::na_if(., ''))
})


# Complete templates
# Create empty dataframes
template_filenames <-
  list.files("templates/bander_portal",
             pattern = ".xlsx",
             full.names = TRUE)
template_colnames <-
  lapply(template_filenames, function(x)
    suppressWarnings(colnames(readxl::read_excel(x))))
names(template_colnames) <- basename(template_filenames)


band_no_aux_col <-
  unlist(template_colnames[names(template_colnames)
                    [grepl("band", names(template_colnames), ignore.case = TRUE) &
                     grepl("no", names(template_colnames), ignore.case = TRUE)]])
band_no_aux <-
  data.frame(matrix(
    ncol = length(band_no_aux_col),
    nrow = nrow(cap.data_no_aux$'1'),
    dimnames = list(NULL, band_no_aux_col)
  ),
  check.names = FALSE)

recap_no_aux_col <-
  unlist(template_colnames[names(template_colnames)
                    [grepl("recap", names(template_colnames), ignore.case = TRUE) &
                     grepl("no", names(template_colnames), ignore.case = TRUE)]])
recap_no_aux <-
  data.frame(matrix(
    ncol = length(recap_no_aux_col),
    nrow = nrow(cap.data_no_aux$'R'),
    dimnames = list(NULL, recap_no_aux_col)
  ),
  check.names = FALSE)

band_aux_col <-
  unlist(template_colnames[names(template_colnames)
                    [grepl("band", names(template_colnames), ignore.case = TRUE) &
                     grepl("aux", names(template_colnames), ignore.case = TRUE)]])
band_aux <-
  data.frame(matrix(
    ncol = length(band_aux_col),
    nrow = nrow(cap.data_aux$'1'),
    dimnames = list(NULL, band_aux_col)
  ),
  check.names = FALSE)

recap_aux_col <-
  unlist(template_colnames[names(template_colnames)
                    [grepl("recap", names(template_colnames), ignore.case = TRUE) &
                     grepl("aux", names(template_colnames), ignore.case = TRUE)]])
recap_aux <-
  data.frame(matrix(
    ncol = length(recap_aux_col),
    nrow = nrow(cap.data_aux$'R'),
    dimnames = list(NULL, recap_aux_col)
  ),
  check.names = FALSE)

band_no_aux_ref<- capture_cols %>% dplyr::filter(BBL_template=="band_no_aux")
recap_no_aux_ref<- capture_cols %>% dplyr::filter(BBL_template=="recap_no_aux")
band_aux_ref<- capture_cols %>% dplyr::filter(BBL_template=="band_aux")
recap_aux_ref<- capture_cols %>% dplyr::filter(BBL_template=="recap_aux")



## Fill banding - no aux
auto.match.num <-
  which(band_no_aux_ref$BBL_col %in% colnames(band_no_aux) &
          !is.na(band_no_aux_ref$my_col))


for (a in na.omit(auto.match.num)) {
  band_no_aux[[band_no_aux_ref$BBL_col[a]]] <-
    cap.data_no_aux$'1'[[band_no_aux_ref$my_col[a]]]
}

band_no_aux[["Replaced Band Number"]] <-
  unlist(cap.data_no_aux$'1'["BandNumberIn"])

banded_legs <- c()
banded_legs <-
  c(banded_legs, sapply(1:nrow(cap.data_no_aux$'1'), function(x)
    substring(colnames(cap.data_no_aux$'1'[leg_cols])[cap.data_no_aux$'1'[x, leg_cols] %in% "00"][1], 2, 2)))

band_no_aux[["Banded Leg"]]<- banded_legs

## Fill recaptures - no aux
auto.match.num <-
  which(recap_no_aux_ref$BBL_col %in% colnames(recap_no_aux) &
          !is.na(recap_no_aux_ref$my_col))


for (a in na.omit(auto.match.num)) {
  recap_no_aux[[recap_no_aux_ref$BBL_col[a]]] <-
    cap.data_no_aux$'R'[[recap_no_aux_ref$my_col[a]]]
}

banded_legs <- c()
banded_legs <-
  c(banded_legs, sapply(1:nrow(cap.data_no_aux$'R'), function(x)
    substring(colnames(cap.data_no_aux$'R'[leg_cols])[cap.data_no_aux$'R'[x, leg_cols] %in% "00"][1], 2, 2)))

recap_no_aux[["Banded Leg"]]<- banded_legs


## Fill banding - aux
auto.match.num <-
  which(band_aux_ref$BBL_col %in% colnames(band_aux) &
          !is.na(band_aux_ref$my_col))

manual.match.num <-
  which(!band_aux_ref$BBL_col %in% colnames(band_aux))


for (a in na.omit(auto.match.num)) {
  band_aux[[band_aux_ref$BBL_col[a]]] <-
    cap.data_aux$'1'[[band_aux_ref$my_col[a]]]
}


for (a in 1:nrow(cap.data_aux$'1')) {
  n <- 0
  marker_string <- c()
  for (b in c(leg_cols[grepl("Out",leg_cols)])) {
    if (!is.na(cap.data_aux$'1'[a, b])) {
      for (c in unlist(strsplit(paste0(cap.data_aux$'1'[a, b]), "/"))) {
        n <- n + 1
         marker_cols <-
            colnames(band_aux)[grepl(n, colnames(band_aux))]
        
        band_aux[[marker_cols[1]]][a] <-
          c
        
        code_col <-
          "FlagCodeOut"[sapply("69", function(x)
            grepl(x, c))]
        if (length(code_col) != 0) {
          band_aux[[marker_cols[2]]][a] <-
            cap.data_aux$'1'[[code_col]][a]
        }
        
        color_col <-
          c("FlagColorOut",
            paste0(b, "_colorband"))[sapply(c("69", "01A"), function(x)
              grepl(x, c))]
        if (length(color_col) != 0) {
          band_aux[[marker_cols[3]]][a] <-
            cap.data_aux$'1'[[color_col]][a]
        }
        
        code_color_col <-
          "FlagCodeColorOut"[sapply("69", function(x)
            grepl(x, c))]
        if (length(code_color_col) != 0) {
          band_aux[[marker_cols[4]]][a] <-
            cap.data_aux$'1'[[code_color_col]][a]
        }
        
        band_aux[[marker_cols[5]]][a] <-
          c("L", "R")[sapply(c(".{1}L", ".{1}R"), function(x)
            grepl(x, b))]
        
        band_aux[[marker_cols[6]]][a] <-
          paste0("L", c("B", "A")[sapply(c("^L", "^U"), function(x)
            grepl(x, b))])
        
        if (cap.data_aux$'1'[a, b] == "00") {
          band_aux[["Banded Leg"]][a] <-
            c("L", "R")[sapply(c(".{1}L", ".{1}R"), function(x)
              grepl(x, b))]
        }
      }
    }
    
  }
  
  for (b in c("TagType1", "TagType2")) {
    if (!is.na(cap.data_aux$'1'[a, b])) {
      n <- n + 1
      
      status <-
        cap.data_aux$'1'[a, paste0("TagStatus", c("1", "2")[sapply(c("1", "2"), function(x)
          grepl(x, b))])]
      
      if (!TRUE %in% sapply(leg_cols, function(x)
        grepl(cap.data_aux$'1'[a, b], cap.data_aux$'1'[a, x])) &
        status != "Removed") {
  
        band_aux[[colnames(band_aux)[grepl(n, colnames(band_aux))][1]]][a] <-
          unlist(cap.data_aux$'1'[a, b])
        
      }
    }
  }
  
  end.num <-
    c(27, 33, 39, 45, 51, 57)[sapply(c(1, 2, 3, 4, 5, 6), function(x)
      grepl(x, n))]
  
  marker_string <-
    tidyr::replace_na(unlist(band_aux[a, 22:end.num]), "")
  
  for (b in
       names(marker_string)[grepl("Side", names(marker_string))]) {
    marker_string <-
      append(marker_string, c("", ""), after = which(names(marker_string) == b))
  }
  
  band_aux[['All Marker Info At Release']][a] <-
    paste0(paste0(marker_string, collapse = "|"), "|")
}

band_aux[["Replaced Band Number"]]<-  unlist(cap.data_aux$'1'["BandNumberIn"])


## Fill recaptures - aux
auto.match.num <-
  which(recap_aux_ref$BBL_col %in% colnames(recap_aux) &
          !is.na(recap_aux_ref$my_col))

for (a in na.omit(auto.match.num)) {
  recap_aux[[recap_aux_ref$BBL_col[a]]] <-
    cap.data_aux$'R'[[recap_aux_ref$my_col[a]]]
}


for (a in 1:nrow(cap.data_aux$'R')) {
  in.num <- 0
  out.num <- 0
  
  for (b in leg_cols) {
    if (!is.na(cap.data_aux$'R'[a, b])) {
      for (c in unlist(strsplit(paste0(cap.data_aux$'R'[a, b]), "/"))) {
        if (grepl("In", b)) {
          in.num <- in.num + 1
          n <- in.num
          marker_cols <-
            colnames(recap_aux)[grepl(n, colnames(recap_aux)) &
                                  grepl("capture", colnames(recap_aux))]
          
        } else if (grepl("Out", b)) {
          out.num <- out.num + 1
          n <- out.num
          marker_cols <-
            colnames(recap_aux)[grepl(n, colnames(recap_aux)) &
                                  grepl("release", colnames(recap_aux))]
        }
        
        recap_aux[[marker_cols[1]]][a] <-
          c
        
        dir <-  c("In", "Out")[sapply(c("In", "Out"), function(x)
          grepl(x, b))]
        
        code_col <-
          paste0("FlagCode", dir)[sapply(c("69"), function(x)
            grepl(x, c))]
        if (length(code_col) != 0) {
          recap_aux[[marker_cols[2]]][a] <-
            cap.data_aux$'R'[[code_col]][a]
        }
        
        color_col <-
          c(paste0("FlagColor", dir), paste0(b, "_colorband"))[sapply(c("69", "01A"), function(x)
            grepl(x, c))]
        if (length(color_col) != 0) {
          recap_aux[[marker_cols[3]]][a] <-
            cap.data_aux$'R'[[color_col]][a]
        }
        
        code_color_col <-
          paste0("FlagCodeColor", dir)[sapply(c("69"), function(x)
            grepl(x, c))]
        if (length(code_color_col) != 0) {
          recap_aux[[marker_cols[4]]][a] <-
            cap.data_aux$'R'[[code_color_col]][a]
        }
        
        recap_aux[[marker_cols[5]]][a] <-
          c("L", "R")[sapply(c(".{1}L", ".{1}R"), function(x)
            grepl(x, b))]
        
        recap_aux[[marker_cols[6]]][a] <-
          paste0("L", c("B", "A")[sapply(c("^L", "^U"), function(x)
            grepl(x, b))])
        
        if (cap.data_aux$'R'[a, b] == "00") {
          recap_aux[["Banded Leg"]][a] <-
            c("L", "R")[sapply(c(".{1}L", ".{1}R"), function(x)
              grepl(x, b))]
        }
        
      }
    }
  }
  
  for (b in c("TagType1", "TagType2")) {
    if (!is.na(cap.data_aux$'R'[a, b]) &
        !TRUE %in% sapply(leg_cols, function(x)
          grepl(cap.data_aux$'R'[a, b], cap.data_aux$'R'[a, x]))) {
      status <-
        cap.data_aux$'R'[a, paste0("TagStatus", c("1", "2")[sapply(c("1", "2"), function(x)
          grepl(x, b))])]
      
      dir <-
        list("Out", "In",
          c("In", "Out"),
          c("In", "Out"))[c("Deployed",
                            "Removed",
                            "Replaced",
                            "Retained") %in% status]
      
      for (c in unlist(dir)) {
        direction  <-
          c("capture", "release")[sapply(c("In", "Out"), function(x)
            grepl(x, c))]
        
        if (grepl("In", c)) {
          in.num <- in.num + 1
          n <- in.num
        } else if (grepl("Out", c)) {
          out.num <- out.num + 1
          n <- out.num
        }
        
        recap_aux[[colnames(recap_aux)[grepl(n, colnames(recap_aux)) &
                                         grepl(direction, colnames(recap_aux))][1]]][a] <-
          unlist(cap.data_aux$'R'[a, b])
        
      }
    }
  }
  
  if(n==0){
    n<- 1
  }
  
  capture.end.num <-
    c(29, 35, 41, 47, 53, 59)[sapply(c(1, 2, 3, 4, 5, 6), function(x)
      grepl(x, n))]

    marker_string <-
      tidyr::replace_na(unlist(recap_aux[a, 24:capture.end.num]), "")
  
  for (b in
       names(marker_string)[grepl("Side", names(marker_string))]) {
    marker_string <-
      append(marker_string, c("", ""), after = which(names(marker_string) == b))
  }
  
    if (paste0(paste0(marker_string, collapse = "|"), "|") == "00||||R|||LB|") {
      recap_aux[a, colnames(recap_aux)[grepl("1", colnames(recap_aux)) &
                                         grepl("capture", colnames(recap_aux))]] <- NA
      
    } else {
      recap_aux[['All Marker Info At Capture']][a] <-
        paste0(paste0(marker_string, collapse = "|"), "|")
    }
  
  
  release.end.num <-
    c(65, 71, 77, 83, 89, 95)[sapply(c(1, 2, 3, 4, 5, 6), function(x)
      grepl(x, n))]
  
  marker_string <-
    tidyr::replace_na(unlist(recap_aux[a, 60:release.end.num]), "")
  
  for (b in
       names(marker_string)[grepl("Side", names(marker_string))]) {
    marker_string <-
      append(marker_string, c("", ""), after = which(names(marker_string) == b))
  }
  
  recap_aux[['All Marker Info At Release']][a] <-
    paste0(paste0(marker_string, collapse = "|"), "|")
  
}

```

#### Export files

```{r}

message(cat(
  paste0(
    "The following data files have been processed and are ready for Bander Portal.\n"
  ),
  paste0(names(data.list), sep = "\n"),
  paste0("\n\nProvide a prefix for the newly written files.\n")
))

prefix <-
  gsub(" ", "_", noquote(as.character(readline(prompt =))))

if (!TRUE %in% sapply(c("_", ".", "-"), function(x)
  endsWith(prefix, x))) {
 prefix<- paste0(prefix,"_")
}

for(a in c("band_no_aux", "band_aux", "recap_no_aux", "recap_aux")) {
  if (rowSums(is.na(get(a)))[1] != ncol(get(a))) {
    openxlsx::write.xlsx(get(a),
                         paste0(
                           processed.data.path,
                           prefix,
                           a,
                           "_",
                           format(Sys.time(), '%Y%m%d-%H%M%S'),
                           ".xlsx"
                         ))
    
  }
}

message(cat(
  paste0(
    "The files were sucessfully written to '" ,
    processed.data.path,
    "'"
  )
))

utils::browseURL(processed.data.path)

```

# Survey data transformations

### ebird

```{r}
# survey.to.ebird
library("auk")

# ebird
# usfwslandbirds
# fwslandbirds
# API key: e2m7tt6sfo4n


```

# Rename photos

### Provide inputs

```{r}
photo.file.path <- "C:/Users/hvincelette/OneDrive - DOI/Documents/Fieldwork_wrap/2024/Eielson/photos/ALMS_points/CFGesmundo/"

ref.file.path<- "data-processed/to_archive/"

date.col<- "Date"
date.format <- "%m/%d/%Y"
time.col<- "StartTime"
time.format<- "%H:%M"
obs.col<- "ObserverID"
ref.col<- "UnitID"
prefix<- "EIEL"
missing.photo<- c("221","181")

variation <- c("")

```

### Import data

```{r}
# Import ref data file(s)
ref.file <- importer(
  path = ref.file.path,
  multiple = FALSE,
  graphics = TRUE,
  column.format = list(
    c(column = date.col, format = date.format),
    c(column = time.col, format = time.format)
  )
)

```

### Filter data

```{r}

ref.file <- ref.file %>%
  dplyr::mutate({{date.col}} := lubridate::as_date(.data[[date.col]], format = date.format)) %>%
  dplyr::mutate({{time.col}} := lubridate::as_datetime(.data[[time.col]], format = time.format)) %>%
  dplyr::mutate("temp:Year" := format(.data[[date.col]], "%Y"))

year.options <-
  ref.file %>%
  dplyr::select("temp:Year") %>%
  dplyr::filter("temp:Year" != "") %>%
  na.omit() %>%
  purrr::pluck("temp:Year") %>%
  unique() %>%
  sort()

year.choice <- utils::select.list(
  year.options,
  graphics = TRUE,
  multiple = FALSE,
  title = cat(
    paste0("\nSelect a year.\nEnter 0 to proceed with all years.\n")
  )
)
 
if(year.choice !=""){
   ref.file <- ref.file %>% dplyr::filter(`temp:Year` == year.choice)
}

obs.choice <- utils::select.list(
  c(unique(na.omit(ref.file[[obs.col]]))),
  multiple = FALSE,
  graphics = TRUE,
  title = cat(
    paste0(
      "\nSelect an observer.\nNote, photos taken by each observer must be processed individually due to the possibility of concurrent timestamps.\n"
    )
  )
)

if (length(obs.choice) != 0) {
  ref.file <- ref.file %>% dplyr::filter(.[[obs.col]] %in% obs.choice)
}

```

### Formulate names

```{r}

ref.file <- ref.file %>%
  dplyr::select(c({{date.col}}, {{time.col}}, {{ref.col}})) %>%
  dplyr::distinct() %>%
  dplyr::arrange(.[[date.col]], .[[time.col]]) 

ref.order <- ref.file %>%
  purrr::pluck(ref.col) %>%
  sub(paste0(prefix, "_"), "", .) %>%
  subset(!(. %in% missing.photo)) %>%
  rep(., each=length(variation))

variation.vector <- rep(variation, length(fs::dir_ls(path = photo.file.path, type = "file")) / 4)

date.taken <- fs::dir_ls(path = photo.file.path, type = "file") %>%
  exifr::read_exif(tags =
                     c("DateTimeOriginal")) %>%
  dplyr::arrange(DateTimeOriginal) %>%
  dplyr::mutate_at("SourceFile", basename) %>%
  dplyr::mutate(Ext= tools::file_ext(SourceFile)) %>%
  dplyr::mutate_at(
    "DateTimeOriginal",
    ~ lubridate::as_date(., format = "%Y:%m:%d %H:%M:%S") %>% format(., "%Y%m%d")
  )


if (length(ref.order) != nrow(date.taken)) {
  temp <- ref.file %>%
    dplyr::group_by(.[[date.col]]) %>%
    dplyr::summarize(RefTotal = dplyr::n())
  
  message(
    "Images and reference points are not of equal length.\nCheck missing data are accurately reported before continuing.\n"
    
  )
  
  message(huxtable::print_screen(
    huxtable::hux(
      date.taken %>%
        dplyr::group_by(DateTimeOriginal) %>%
        dplyr::summarize(PhotoTotal = dplyr::n() / length(variation)) %>%
        dplyr::mutate(ReferenceTotal = temp$RefTotal)
    ),
    colnames = FALSE
  ))
  
}

if (any(is.na(date.taken$DateTimeOriginal)) == TRUE) {
  browseURL(photo.file.path)
  
  for (a in which(is.na(date.taken$DateTimeOriginal))) {
    pass <- 0
    while (pass == 0) {
      message(cat(
        paste0(
          "\nThe image ",
          date.taken$SourceFile[a],
          " is missing a capture date.\nProvide a date formatted as %Y%m%d (e.g., 20240630).\n"
        )
      ))
      
      new.date <- as.character(readline(prompt = ""))
      
      if (nchar(new.date) != 8 |
          new.date == "" |
          is.na(suppressWarnings(as.numeric(new.date)))) {
        message("Incorrect date format.\n")
      } else {
        date.taken$DateTimeOriginal[date.taken$SourceFile == date.taken$SourceFile[a]] <- new.date
        pass <- 1
      }
    }
  }
}

date.taken <- date.taken %>%
  dplyr::mutate(
    "FileName" = paste0(
      prefix,
      "_",
      ref.order,
      # "_",
      # variation.vector,
      "_",
      date.taken$"DateTimeOriginal",
      ".",
      date.taken$"Ext"
    )
  )

file.rename(
  paste0(photo.file.path, date.taken$SourceFile),
  paste0(photo.file.path, date.taken$FileName)
)

```

# Movebank download

### Provide inputs

Verify the stored login credentials are correct, and add/remove credentials as needed.

```{r warning=FALSE, include=FALSE, results=FALSE}

# Check existing login credentials
keyring::key_list()

# Add login credentials
move2::movebank_store_credentials(username = "mbmlandbirds",
                                  password = "",
                                  key_name = "movebank")

# Remove login credentials
move2::movebank_remove_credentials(key_name = getOption("move2_movebank_key_name"))


```

*Optional: If you want to import Movebank data from a secondary account, paste the associated service name listed in the key list (e.g., "myOtherAccount") and run the following code. Note the account with the service name "movebank" is the default, so you only need to run this code if you want to access a different account. Restart R or execute* `options("move2_movebank_key_name" = "movebank")` *to* *return to the default account. See* `vignette("movebank", package="move2")` *for more details.*

```{r}

keyring::key_list()

options("move2_movebank_key_name" = "movebank")

```

### Import data

Run the following code to import location data from one or more studies into R. Single study imports have the option of selecting a time range of location data, whereas multiple study imports include all location data. By default, the location and reference data are both imported

```{r warning=FALSE, include=FALSE, results=FALSE}
          
# Import Movebank location and/or reference data
df.loc <- get.move.data(
  location = TRUE,
  reference = FALSE,
  remove_movebank_outliers <- FALSE,
  omit_derived_data <- FALSE
)

Movebank_dictionary <- readxl::read_excel("reference/movebank/Migratory_Tracking_data_dictionary.xlsx", na = "")

load("reference/movebank/animal_id_key.RData")

aou_code <- read.csv("reference/IBP-AOS-LIST23.csv", na = "")

# Unlist dataframes (if necessary)
if(any(sapply(import, function(x)
  any(class(x) == "list")))==TRUE) {
  import.dfs <- rrapply::rrapply(
    import,
    classes = "data.frame",
    how = "flatten",
    options = list(namesep = "-",
                   simplify = FALSE)
  )
} else if (inherits(import, "data.frame") == TRUE) {
  import.dfs <- list(import)
  
} else{
  import.dfs <- import
}


```

### Prepare data

```{r}

# Extract coordinates
for(x in 1:length(import.dfs)) {
  loc.cols <-
    colnames(dplyr::select(import.dfs[[x]], matches("location")))
  for (a in loc.cols) {
    if ("sfc_POINT" %in% class(import.dfs[[x]][[a]])) {
      names <- names(unlist(import.dfs[[x]][[a]][1]))
      names <- sapply(names, function(x)
        sub(pattern = "^argos_", replacement = "argos:", x), USE.NAMES = FALSE)
      suppressWarnings(
        import.dfs[[x]] <-  import.dfs[[x]] %>%
          tibble::add_column(
            !!names[1] := sf::st_coordinates(import.dfs[[x]][[a]])[, 1],
            !!names[2] := sf::st_coordinates(import.dfs[[x]][[a]])[, 2],
            .before = paste0(a)
          ) %>%
          dplyr::select(!a)
      )
      
    }
  }
}

# Update field names
import.dfs <- import.dfs %>%
  purrr::map(
    .f = ~ .x %>%
      setNames(., gsub(
        pattern = "_", replacement = "-", names(.)
      )) %>%
      setNames(., sub(
        pattern = "^argos-", replacement = "argos:", names(.)
      )) %>%
      data.table::setnames(
        .,
        old = c(
          "individual-id",
          "nick-name",
          "weight",
          "individual-comments",
          "individual-number-of-deployments"
        ),
        new = c(
          "animal-id",
          "nickname",
          "tag-mass",
          "animal-comments",
          "animal-number-of-deployments"
        )
        ,
        skip_absent = TRUE
      )
  )


movebank_attributes<- Movebank_dictionary$codeName[Movebank_dictionary$domainItem_value=="dataField"]

all_colnames <- import.dfs %>%
  purrr::map_df(~ names(.x) %>%
                  tibble::enframe(name = NULL)) %>% dplyr::pull(value)


new_colnames <-
  sapply(all_colnames[!all_colnames %in% movebank_attributes], function(x) {
    grep(paste0("-", x),
         movebank_attributes,
         value = TRUE)
  }) %>% purrr::compact(.)


if (length(new_colnames) != 0) {
  import.dfs <- import.dfs %>%
    purrr::map(.f = ~ data.table::setnames(
      .x,
      old = names(new_colnames),
      new = unlist(new_colnames),
      skip_absent = TRUE
    ))
}

  
# Add missing columns
req_cols <- c("animal-ring-id", "animal-marker-id")

import.dfs <- import.dfs %>%
  purrr::map(.f = ~ .x %>%
               dplyr::mutate(!!!setNames(
                 rep(NA, length(setdiff(
                   req_cols, colnames(.x)
                 ))), setdiff(req_cols, colnames(.x))
               )) %>% dplyr::relocate(
                 c("animal-ring-id", "animal-marker-id", "tag-local-identifier"),
                 .after = "animal-id"
               ))


import.dfs[grep("reference-data$", names(import.dfs))] <-
  import.dfs[grep("reference-data$", names(import.dfs))] %>%
  purrr::map(
    .f = ~ .x %>%
      dplyr::mutate(
        "deploy-date" = lubridate::as_date(.$"deploy-on-timestamp"),
        .after = "deploy-on-timestamp"
      ) %>%
      dplyr::mutate("deploy-year" = as.character(
        lubridate::year(.$"deploy-on-timestamp"),
        .after = "deploy-date"
      ))
  )


# Link banding data

## Import banding files
# rdr_folders <-
#   dir(path = "//ifw7ro-file.fws.doi.net/datamgt/mbm",
#       pattern = "mbmlb")
# 
# 
# banding_files<- lapply(rdr_folders, function(x) {
#     FWSAkRDRtools::read.tables(
#       pattern = "banding.*\\.csv$",
#       project = x,
#       subfolder.path = "data/final_data",
#       recursive = FALSE,
#       all = TRUE
#     )
# })
# 
# save(banding_files, file = "reference/movebank/banding_files.RData")

all_band_data <-
  banding_files %>%
  purrr::discard(is.null) %>%
  plyr::ldply(.) %>%
  dplyr::mutate_at(dplyr::vars("BandNumberOut", "Year"), as.character)


# Join missing band numbers
# na_animal_ring <- import.dfs$`reference-data` %>%case
#   dplyr::filter(is.na(`animal-ring-id`)) %>%
#   dplyr::inner_join(
#     .,
#     aou_code[, c("SCINAME", "SPEC")],
#     by = c("individual-taxon-canonical-name" = "SCINAME"),
#     keep = FALSE,
#     relationship = "many-to-many"
#   ) %>%
#   dplyr::left_join(
#     .,
#     all_band_data[, c("Year", "BandNumberOut", "SpeciesCode", "FlagCodeOut")],
#     by = c(
#       "SPEC" = "SpeciesCode",
#       "deploy-year"  = "Year",
#       "individual-local-identifier" = "FlagCodeOut"
#     ),
#     keep = FALSE,
#     relationship = "many-to-many"
#   ) %>%
#   dplyr::mutate("animal-ring-id" = `BandNumberOut`,
#                 "animal-marker-id" = `individual-local-identifier`) %>%
#   dplyr::select(
#     "deploy-year",
#     "individual-taxon-canonical-name",
#     "animal-id",
#     "animal-ring-id",
#     "animal-marker-id"
#   ) %>%
#   dplyr::distinct() %>%
#   dplyr::mutate_at("animal-ring-id",
#                    ~ as.character(.)) %>%
#   dplyr::mutate_at(
#     "animal-ring-id",
#     ~ dplyr::case_when(
#       `animal-marker-id` == "CL/EX" ~ "123233886",
#       `animal-marker-id` == "04A" ~ "129210985",
#       `animal-marker-id` == "E4" ~ "137213263",
#       `animal-marker-id` == "E3" ~ "137213260",
#       TRUE ~ `animal-ring-id`
#     )
#   )
# 
# 
# animal_id_key <- import.dfs$`reference-data` %>%
#   dplyr::filter(!is.na(`animal-ring-id`)) %>%
#   dplyr::select(
#     "deploy-year",
#     "individual-taxon-canonical-name",
#     "animal-id",
#     "animal-ring-id",
#     "animal-marker-id"
#   ) %>%
#   dplyr::distinct() %>%
#   rbind(na_animal_ring) %>%
#   dplyr::mutate_at("animal-ring-id", ~ gsub(pattern = "-", replacement = "", .)) %>%
#   suppressWarnings(dplyr::mutate_at(
#     # if marker id occurs in numeric ring id
#     "animal-marker-id",
#     ~ dplyr::case_when(
#       is.na(as.numeric(`animal-ring-id`)) ~ `animal-ring-id`,
#       TRUE ~ `animal-marker-id`
#     )
#   )) %>%
#   suppressWarnings(dplyr::mutate_at("animal-ring-id", ~ ifelse(is.na(
#     as.numeric(`animal-ring-id`)
#   ), NA, `animal-ring-id`))) %>%
#   dplyr::mutate_all(as.character) %>%
#   dplyr::inner_join(
#     .,
#     aou_code[, c("SCINAME", "SPEC")],
#     by = c("individual-taxon-canonical-name" = "SCINAME"),
#     keep = FALSE,
#     relationship = "many-to-many"
#   ) %>%
#   dplyr::left_join(
#     .,
#     all_band_data[, c("Year", "BandNumberOut", "SpeciesCode", "FlagCodeOut")],
#     by = c(
#       "SPEC" = "SpeciesCode",
#       "deploy-year"  = "Year",
#       "animal-ring-id" = "BandNumberOut"
#     ),
#     keep = FALSE,
#     relationship = "many-to-many"
#   ) %>%
#   dplyr::mutate_at(
#     "animal-marker-id",
#     ~ dplyr::case_when(is.na(.) ~ `FlagCodeOut`, TRUE ~ `animal-marker-id`)
#   )
# 
# marker_id_check <- animal_id_key %>%
#   dplyr::filter(`animal-marker-id` != `FlagCodeOut`) %>%
#   dplyr::filter(!`animal-marker-id` %in% unlist(sapply(`FlagCodeOut`, function(x)
#     grep(x, `animal-marker-id`, value = TRUE)))) %>%
#   dplyr::mutate("animal-marker-id" = FlagCodeOut) %>%
#   dplyr::select(-"FlagCodeOut")
# 
# 
# animal_id_key <- animal_id_key %>%
#   dplyr::select(-"FlagCodeOut") %>%
#   dplyr::rows_update(
#     marker_id_check,
#     by = c(
#       "deploy-year",
#       "individual-taxon-canonical-name",
#       "animal-id",
#       "animal-ring-id"
#     )
#   )
# 
# save(animal_id_key, file = "reference/movebank/animal_id_key.RData")

# Check
dup_ring <- animal_id_key %>%
  dplyr::distinct(
    `deploy-year`,
    `animal-id`,
    `animal-ring-id`,
    `individual-taxon-canonical-name`,
    `animal-marker-id`
  ) %>%
  dplyr::filter(!is.na(`animal-ring-id`)) %>%
  subset(duplicated(`animal-ring-id`) |
           duplicated(`animal-ring-id`, fromLast = TRUE)) %>%
  data.table::setorder(`animal-ring-id`, na.last = TRUE)


animal_id_key <- animal_id_key %>%
  setNames(paste0("temp:", names(.)))
  

suppressWarnings(
  import.dfs<- 
    import.dfs %>%
    purrr::map(
      .f = ~ .x %>%
        dplyr::mutate("id" = seq_along(1:nrow(.x))) %>%
        dplyr::mutate_at(
          "animal-ring-id",
          ~ gsub(pattern = "-",
                 replacement = "", .) %>%
            as.numeric(.) # Only run this if all band numbers should be numeric
        ) %>%
        dplyr::mutate_at(dplyr::vars(
          c("animal-id",
            "animal-ring-id",
            "animal-marker-id")
        ), as.character) %>%
        dplyr::left_join(
          .,
          animal_id_key[, c(
            "temp:animal-id",
            "temp:animal-ring-id",
            "temp:animal-marker-id",
            "temp:deploy-year"
          )],
          by = c("animal-id" = "temp:animal-id"),
          keep = FALSE,
          relationship = "many-to-many" # different years
        ) %>%
        dplyr::mutate_at(
          "animal-ring-id",
          ~ dplyr::case_when(is.na(.) ~ `temp:animal-ring-id`, TRUE ~ `animal-ring-id`)
        ) %>%
        dplyr::mutate_at(
          "animal-marker-id",
          ~ dplyr::case_when(is.na(.) ~ `temp:animal-marker-id`, TRUE ~ `animal-marker-id`)
        ) %>%
        dplyr::select(-c(tidyselect::any_of(
          c(
            "deployment-local-identifier",
            "animal-nickname",
            "individual-local-identifier",
            "deploy-on-person",
            "deploy-off-person",
            grep(
              "-comments",
              colnames(.),
              value = TRUE,
              ignore.case = TRUE
            )
          )
        ), tidyselect::starts_with("temp:"))) %>% 
    dplyr::distinct()
    )
)

# Check
dup_id <-
  import.dfs %>%
  purrr::map(
    .f = ~ .x %>%
      dplyr::select(
        `id`,
        `animal-id`,
        `animal-ring-id`,
        `individual-taxon-canonical-name`,
        `animal-marker-id`
      ) %>%
      subset(
        duplicated(`id`) |
          duplicated(`id`, fromLast = TRUE)
      )
  )


## Prep band info
suppressWarnings(
  band_info <-
    all_band_data %>%
    dplyr::select(
      c(
        "SpeciesCode",
        "Year",
        "Date",
        "Latitude_dec",
        "Longitude_dec",
        "BandNumberOut",
        "Mass_g",
        "Age",
        "CHDSex",
        "FieldSex",
        "FlagCodeOut"
        # , grep(
        #   "tag",
        #   colnames(all_band_data),
        #   value = TRUE,
        #   ignore.case = TRUE
        # )
      )
    ) %>%
    dplyr::mutate_at("Date",~format(as.Date(., format = "%m/%d/%Y"), "%Y-%m-%d")) %>%
    dplyr::mutate_at("Mass_g",~units::set_units(., "g", mode = "standard")) %>%
    dplyr::mutate_at(c("FieldSex", "CHDSex"), ~tolower(.) %>%
                     dplyr::na_if(., "u")) %>%
    dplyr::mutate_at("Age", ~dplyr::recode(., HY = "juvenile",
                                          L = "juvenile",
                                          AHY = "adult",
                                          SY = "adult",
                                          ASY = "adult",
                                          TY = "adult",
                                          ATY = "adult") %>%
                                          dplyr::na_if(.,"U")
                                          ) %>%
    
    dplyr::mutate_at("Year",  ~ ifelse(
      is.na(.) & !is.na("Date"),
      format(as.Date(all_band_data$Date, format = "%d/%m/%Y"), "%Y"),
      .
    )) %>%
    dplyr::mutate_at(dplyr::vars(c("BandNumberOut","Year")), as.character) %>%
    dplyr::rowwise() %>%
    dplyr::mutate_at("FlagCodeOut", ~ ifelse(
      !is.na(as.numeric(.)),
      format(as.numeric(.),
             scientific = FALSE),
      .
    )) %>%
    setNames(paste0("temp:", names(.)))
)


## Join sex results (usually in data postprocessing)
band_info <- list(band_info) %>%
  purrr::map(
    .f = ~ .x %>%
      dplyr::mutate(!!!setNames(
        rep(NA, length(setdiff(
          "temp:CHDSex", colnames(.x)
        ))), setdiff("temp:CHDSex", colnames(.x))
      )) %>%
      dplyr::relocate("temp:CHDSex", .before = "temp:FieldSex") %>%
      dplyr::left_join(
        .,
        dplyr::distinct(sex_results[, c("BandNumber", "Sex")]),
        by = c("temp:BandNumberOut" = "BandNumber"),
        keep = FALSE,
        relationship = "many-to-many"
      ) %>%
      dplyr::mutate_at("temp:CHDSex", ~ dplyr::case_when(is.na(.) ~ Sex, TRUE ~ `temp:CHDSex`)) %>%
      dplyr::select(-"Sex")
  ) %>% `[[`(1)


## Mutate/fill missing values in reference dfs
req_cols <-
  c(
    "animal-life-stage",
    "animal-sex",
    "animal-mass",
    "tag-manufacturer-name",
    "tag-model",
    "capture-longitude",
    "capture-latitude"
  )

import.dfs[grep("reference-data$", names(import.dfs))] <-
  import.dfs[grep("reference-data$", names(import.dfs))] %>%
  purrr::map(
    .f = ~ .x %>%
      dplyr::mutate("id" = seq_along(1:nrow(.x))) %>%
      dplyr::relocate("id") %>%
      dplyr::mutate(!!!setNames(
        rep(NA, length(setdiff(
          req_cols, colnames(.x)
        ))), setdiff(req_cols, colnames(.x))
      )) %>%
      dplyr::left_join(
        .,
        dplyr::distinct(band_info[,!(names(band_info) == c("deploy-date"))]),
        by = c("animal-ring-id" = "temp:BandNumberOut",
               "deploy-year" = "temp:Year"),
        keep = FALSE,
        relationship = "many-to-many"
      ) %>%
      dplyr::mutate_at(
        "animal-marker-id",
        ~ dplyr::case_when(is.na(.) ~ `temp:FlagCodeOut`, TRUE ~ `animal-marker-id`)
      ) %>%
      dplyr::mutate_at(
        "animal-life-stage",
        ~ dplyr::case_when(is.na(.) ~ `temp:Age`, TRUE ~ `animal-life-stage`) %>%
          dplyr::recode(
            .,
            HY = "juvenile",
            L = "juvenile",
            AHY = "adult",
            SY = "adult",
            ASY = "adult",
            TY = "adult",
            ATY = "adult",
            "brood rearing" = "adult",
            "brood reaing" = "adult"
          ) %>% tolower(.)
        
      ) %>%
      dplyr::mutate_at(
        "animal-sex",
        ~ dplyr::case_when(
          is.na(.) ~ dplyr::case_when(is.na(`temp:CHDSex`) ~ `temp:FieldSex`,
                                      TRUE ~ `temp:CHDSex`),
          TRUE ~ `animal-sex`
        )
      ) %>%
      dplyr::mutate_at(
        "animal-mass",
        ~ dplyr::case_when(is.na(.) ~ `temp:Mass_g`, TRUE ~ `animal-mass`)
      ) %>%
      dplyr::mutate_at(
        "capture-longitude",
        ~ dplyr::case_when(is.na(.) ~ `temp:Longitude_dec`, TRUE ~ `capture-longitude`)
      ) %>%
      dplyr::mutate_at(
        "capture-latitude",
        ~ dplyr::case_when(is.na(.) ~ `temp:Latitude_dec`, TRUE ~ `capture-latitude`)
      ) %>%
      dplyr::mutate("id.2" = seq_along(1:nrow(.))) %>%
       magrittr::extract(-c(purrr::pluck(dplyr::filter(subset(.,duplicated(id)|duplicated(id, fromLast = TRUE)),`deploy-date`!= `temp:Date`),"id.2"))) %>%
      dplyr::select(-c(starts_with("temp:"), "id.2"))
      
    )
    
# Check
dup_ring_data <-
  import.dfs[grep("reference-data$", names(import.dfs))] %>%
  purrr::map(
    .f = ~ .x %>%
      dplyr::distinct(
        `deploy-year`,
        `animal-id`,
        `animal-ring-id`,
        `individual-taxon-canonical-name`,
        `animal-marker-id`
      ) %>%
      dplyr::filter(!is.na(`animal-ring-id`)) %>%
      subset(
        duplicated(`animal-ring-id`) |
          duplicated(`animal-ring-id`, fromLast = TRUE)
      ) %>%
      data.table::setorder(`animal-ring-id`, na.last = TRUE)
  )

dup_ring_data
dup_ring_key


import.dfs[grep("location-data$", names(import.dfs))] <-
  import.dfs[grep("location-data$", names(import.dfs))] %>%
  purrr::map(.f = ~ .x %>%
               dplyr::filter_at(dplyr::vars(c(
                 grep("lat", colnames(.), value = TRUE),
                 grep("long", colnames(.), value = TRUE)
               )),
               dplyr::any_vars(!is.na(.))))


# Check
invalid_timestamps <-
  import.dfs[grep("location-data$", names(import.dfs))] %>%
  purrr::map(
    .f = ~ .x %>%
      dplyr::mutate("year" = lubridate::year(.$"timestamp"),
                    .after = "timestamp") %>%
      dplyr::mutate("month" = lubridate::month(.$"timestamp"),
                    .after = "year") %>%
      # dplyr::mutate_at(c("year", "month"), as.numeric) %>%
      dplyr::filter((`year` > lubridate::year(Sys.Date())) |
                      (
                        `year` == lubridate::year(Sys.Date()) &
                          `month` > lubridate::month(Sys.Date())
                      )
      )
  )


# Check
lapply(import.dfs, function(x)
  colnames(x)[!colnames(x) %in% movebank_attributes])


```

### Export files

```{r}

# Save dataframes as separate objects 
export<- lapply(import.dfs, function(x)
  split(x, x$`individual-taxon-canonical-name`))

if(any(sapply(export, function(x)
  any(class(x) == "list")))==TRUE) {
  export.dfs <- rrapply::rrapply(
    export,
    classes = "data.frame",
    how = "flatten",
    options = list(namesep = "-",
                   simplify = FALSE)
  )}
# else if (inherits(import, "data.frame") == TRUE) {
#   import.dfs <- list(import)
#   
# } else{
#   import.dfs <- import
# }

export.dfs <-
  export.dfs %>%
  purrr::map(.f = ~ .x %>%
               dplyr::select_if( ~ !(all(is.na(
                 .
               )))))


ref_num <- sapply(1:length(export.dfs), function(x) {
  if (grepl("location-data", names(export.dfs[x]))) {
    # max(as.numeric(export.dfs[[x]]$`event-id`))
    format(max(export.dfs[[x]]$`timestamp`), '%Y%m%d-%H%M%S')
    
  } else {
    format(Sys.time(), '%Y%m%d-%H%M%S')
  }
})

names(export.dfs) <-
  as.data.frame(list(names(export.dfs)), col.names = "original_name") %>%
  tidyr::separate(1,
                  into = c("type", "sp"),
                  sep = "(?<=location-data-)|(?<=reference-data-)") %>%
  dplyr::mutate_at("type", ~ gsub("(^-)|(-$)", "", .)) %>%
  dplyr::mutate("new_name" = paste0(sp, "-", type, "-", ref_num)) %>%
  dplyr::mutate_at("new_name", ~ gsub(" ", "_", .)) %>%
  purrr::pluck("new_name")



dest.path = "data-processed/movebank/"

for (i in seq_along(export.dfs)) {
  write.csv(export.dfs[[i]],
            paste0(dest.path, names(export.dfs[i]), ".csv"),
            na = "",
            row.names = FALSE, quote = FALSE)
  # assign(names(export.dfs[i]),as.data.frame(export.dfs[[i]]))
}
  

# Get updated movebank vocabulary
move.vocab <-
  move2::movebank_get_vocabulary(xml = "http://vocab.nerc.ac.uk/collection/MVB/current/",
                                 return_type = "list",
                                 omit_deprecated = FALSE)

move.vocab <- rrapply::rrapply(
  move.vocab,
  how = "bind",
  options = list(
    simplify = FALSE,
    coldepth = 3,
    namecols = TRUE
  )
) %>%
  tidyr::pivot_wider(
    names_from = "L2",
    values_from = "1",
    values_fill = NA,
    values_fn = unique
  ) %>%
  tidyr::unnest(colnames(.)) %>%
  dplyr::rename("codeName" = "L1") %>%
  dplyr::mutate_at(c("codeName", "altLabel"), ~ stringr::str_replace_all(., c("argos " = "argos:", " " = "-"))) %>%
  dplyr::mutate(
    "units" =
      stringr::str_match(definition, "Units: \\s*(.*?)\\s*;") %>% .[, 2] %>%
      replace(.,  . %in% c(
        "none", "not defined", "unitless", "not specified"
      ), NA) %>%
      gsub(".*none \\((.*)\\).*", "\\1", .)
  ) %>% dplyr::select("codeName", "definition", "units")

write.csv(move.vocab, "move.vocab.csv", na = "", row.names = FALSE)


#!# remove trailing " " & ";"

# move.vocab <- move.vocab %>%
#   dplyr::mutate_at("definition", ~
#                      stringr::str_replace_all(
#                        .,
#                        c(
#                          "Units: \\s*(.*?)\\s*;" = "",
#                          "Values are chosen from a controlled list: \\s*(.*?)\\s*\\." = "",
#                          "Allowed values are \\s*(.*?)\\s*\\." = ""
#                        )
#                      ))

```
